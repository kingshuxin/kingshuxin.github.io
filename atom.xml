<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kingshuxin.github.io</id>
    <title>Hsx</title>
    <updated>2022-09-27T00:49:03.841Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kingshuxin.github.io"/>
    <link rel="self" href="https://kingshuxin.github.io/atom.xml"/>
    <subtitle>Follow your heart.</subtitle>
    <logo>https://kingshuxin.github.io/images/avatar.png</logo>
    <icon>https://kingshuxin.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Hsx</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript]]></title>
        <id>https://kingshuxin.github.io/post/javascript/</id>
        <link href="https://kingshuxin.github.io/post/javascript/">
        </link>
        <updated>2022-09-26T05:42:01.000Z</updated>
        <content type="html"><![CDATA[<p>解释性语言，翻译一行，执行一行，不生成中间文件；<br>
单线程语言，先添加再删除<br>
异步执行<br>
HTML用双引号，JS用单引号<br>
//1.单行注释<br>
/*2.多行注释<br>
变量<br>
变量存在于内存<br>
变量不声明直接赋值也可以使用</p>
<p>数据<br>
Number，Boolean，string，undefined，Null ，symbol  （简单数据类型/原始值）  存放到栈里<br>
复杂数据类型：通过new关键字创建的对象，系统对象、自定义对象（Array、Object、Date）<br>
存放到堆里，在栈里存放地址（十六进制）</p>
<p>简单数据类型传的是值；<br>
复杂类型传参传的是地址；</p>
<p>Number<br>
0-9，a-f.<br>
程序里边数字前边加0表示八进制，前边加0x表示十六进制。<br>
Infinity无穷大<br>
Not a number -- NaN   不是一个数字<br>
isNaN（）  判断是否为非数字</p>
<p>String<br>
转义字符，都是 \  开头<br>
\n 换行符      \t  缩进   \b 空格<br>
字符串长度  length<br>
字符串拼接：字符串+其他类型（数值相加，字符相连！）</p>
<p>Boolean<br>
参与加法运算  true=1   false=0<br>
Undefined<br>
未定义数据类型   参与数字加法结果为NaN<br>
Null<br>
空值  参与数字相加为0</p>
<p>typeof<br>
检测变量类型  特殊：<code>typeof null = object</code></p>
<p>数值类型转换<br>
转化成字符串：toString()    String()  +''(隐式转换)</p>
<p>转化成数字：<br>
①parseInt（string）得到的是整数，并不进位；<br>
例：  parseInt(120.23px)=120;	<br>
②parseFloat(string)   得到的是小数，浮点数<br>
例：  parseInt(120.23px)=120;<br>
③Number('123')；<br>
④利用算数计算，隐式转化,减乘除（没有加法）<br>
'123'-'120'</p>
<p>转换成布尔型<br>
Boolean(  )；  '  '，0，NaN，null，undefined（5个为false）</p>
<p>运算符<br>
算术运算符   不能直接判断浮点数是否相等<br>
==   默认转换类型，18=‘18’   （会把字符串类型转换为数字型）<br>
===  必须值和数据类型都相同</p>
<p>短路计算我会了！</p>
<p>三元表达式<br>
三元表达式？表达式1(true)  ：表达式2(false);</p>
<p>switch<br>
①采用===匹配，类型数值都一致；<br>
②没有break，继续执行下一个case；<br>
switch(e){<br>
case value1：<br>
执行语句1；<br>
break；<br>
case value2：<br>
执行语句2；<br>
break；<br>
default：<br>
执行默认语句；<br>
}</p>
<p>switch和if else区别：<br>
case用于确定值，if else用于范围<br>
switch效率高，有多少if else判断多少次</p>
<p>for 循环多用来计数，while循环用来复杂判断<br>
do while<br>
do{<br>
先执行语句，条件为true时重复执行<br>
}while（）</p>
<p>关键字<br>
continue  退出本次循环，直接调到  i++， 执行下次循环<br>
break 退出整个循环<br>
return返回结果后终止函数，只能返回最后一个值，无return，返回undefined；</p>
<p>数组<br>
创建数组  var arr = []；    var  arr = new  Array()；<br>
索引从0开始，arr[0];<br>
length  属性是可以读写的，用‘empty’来填充，有空间，值为undefined</p>
<p>函数<br>
形参、实参个数不一致<br>
实参&gt;形参：取到形参个数，多余实参不要<br>
实参&lt;形参：多余形参是一个变量，但是没有接收值，为undefined</p>
<p>利用new Funtion('参数1','参数2','函数体')；定义函数<br>
var f = new Function('a','b','console.log(a+b)')</p>
<p>arguments是函数内部对象，包含所有实参，一个伪数组<br>
具有length属性<br>
按照索引方式进行存储<br>
没有真正数组的方法<br>
作用域<br>
全局作用域、局部作用域<br>
函数内部没有声明直接赋值的变量也是全局变量<br>
从执行效率看全局变量和局部变量：<br>
全局变量只有浏览器关闭时才销毁，比较占内存资源<br>
局部变量，当程序执行完毕就会销毁，只能在函数内部使用</p>
<p>预编译<br>
所有声明var、function都提升在当前作用域的最前边<br>
只提升声明，不提升赋值！！！</p>
<p>对象<br>
var obj = new Object();      创建一个空对象</p>
<p>利用构造函数创造对象：<br>
function  构造函数名（）{<br>
this.属性 = 值；<br>
this.方法 = function （） {}<br>
}<br>
new 构造函数名（）；<br>
构造函数名字首字母要大写；<br>
不需要return，就可以返回对象<br>
调用必须使用new<br>
属性和方法前必须加  this</p>
<p>for（key in obj）{<br>
key------属性名<br>
obj [k] -------属性值<br>
}</p>
<p>内置对象Math<br>
Math.PI   圆周率<br>
Math.floor()     向下取整<br>
Math.ceil（）  向上取整<br>
Math.round（） 四舍五入取整<br>
Math.abs()   绝对值<br>
Math.max()  Math.min()  最大值和最小值<br>
Math.random（）随机数 [0,1)<br>
两个数之间的随机整数<br>
Math.floor (Math.random() * (max - min + 1) + min)</p>
<p>内置对象Date<br>
是一个构造函数，需要用new来调用！<br>
Date（）无参数，返回当前时间<br>
+new Date()  返回总的毫秒数（时间戳）<br>
H5新增：Date.now();</p>
<p>内置对象数组Array<br>
var  arr = new Array(2);    创建一个有2个空元素的数组<br>
var arr = new Array(2, 3)   [2,3]<br>
检测是否为数组<br>
instanceof  返回true /  false   例：arr instanceof Array == true;<br>
Array.isArray( )<br>
添加删除数组元素<br>
push(新元素)  末尾添加，push完返回新数组的长度<br>
unshift(新元素)  头部添加 ，unshift 返回新数组的长度<br>
pop（）  删除最后一个元素，返回删除的元素<br>
shift（）删除第一个元素，返回删除的元素<br>
数组排序<br>
reverse（）无参数，翻转数组；<br>
sort ()   （冒泡排序）<br>
arr.sort(function(a,b){<br>
return a - b;升序<br>
return b - a;降序<br>
})<br>
数组元素索引<br>
indexof(数组元素，[起始位置（可选参数）])  返回索引号    找不到返回 -1<br>
lastIndexOf（数组元素，[起始位置（可选参数）]）从后往前找<br>
数组转化成字符串<br>
toString ();   用，隔开元素，无参数<br>
join（分隔符）默认用，隔开元素，不传参数，默认以逗号隔开</p>
<p>concat(arr1,arr2)   链接两个或多个数组，不影响原数组，返回新数组<br>
slice(begin,end)   返回被截取的新数组——把类数组转化为数组<br>
splice(第几个开始，要删除几个)，返回被删除后的新数组，影响原数组<br>
filter	过滤函数元素，返回一个新数组<br>
arr.filter(function(item,index,arr){<br>
reture 判断条件（true则添加新数组，false则舍掉）<br>
})</p>
<p>some 查找数组中是否有符合条件的元素，返回Boolean值(如果找到目标值，就退出循环)<br>
var flag = arr.some(function(item,index,arr){<br>
return item == &quot;pink&quot;<br>
})</p>
<p>some和foreach区别：foreach找到目标元素不会停止循环<br>
some和every区别:every一假即假,some:一真即真<br>
reduce<br>
arr.reduce(function(preValue,currentValue)=&gt;{<br>
return preValue+currentValue;<br>
})</p>
<p>字符串对象<br>
基本包装类型：String、Number、Boolean（先生成临时变量，再销毁）<br>
字符串不可变，只改变地址，原内容还在，所以不要大量拼接字符串<br>
indexOf、lastIndexOf     同数组方法<br>
根据位置返回字符：<br>
chartAt(index)<br>
charCodeAt(index)  返回相应索引号的字符ASCII值，判断用户按键<br>
数组方法  H5新增<br>
concat(str1,str2...)     拼接多个字符串<br>
substr(起始位置，截取几个字符)  截取某段，返回截取部分<br>
replace（被替换，用来替换）  只会替换第一个字符<br>
split('分隔符')   转换为数组，与join相反<br>
toUpperCase()  转换大写<br>
toLowerCase()  转换小写<br>
trim 去除两侧空格，不去中间空格</p>
<p>DOM<br>
H5新增：<br>
document.querySelector('选择器')            只选出第一个，选择器需要加符号<br>
document.querySelectorAll('选择器')	  全部选出</p>
<p>获取特殊元素：<br>
获取body元素  document.body；<br>
获取html元素  document.documentElement；<br>
改变标签内容：<br>
innerText   不识别html标签，去除空格和换行<br>
innerHTML	相反地</p>
<p>排他思想：先排除所有人，然后再单独设置自己的样式</p>
<p>获取属性值：<br>
element.属性			-------获取自带属性值<br>
element.getAttribute('属性')      -------可以获取自定义属性<br>
设置属性值：<br>
element.属性= '值'<br>
element.setAttribute('属性名','属性值')<br>
移除属性：<br>
element.removerAttribute('属性名')</p>
<p>H5规定：自定义属性必须以data-   开头<br>
新增获取自定义属性值：<br>
element.dataset.属性名    /    element.dataset['属性名']<br>
注：element.data是一个对象，自定义属性有多个-链接的单词时，获取要用驼峰命名法</p>
<p>组织链接跳转添加JavaScript:void(0)或者JavaScript:;</p>
<p>节点操作<br>
node.parentNode	最近的一个父节点<br>
node.childNodes		所有的子节点，包含元素节点、文本节点（一般不用）<br>
node.children		所有的元素子节点,<br>
node.firstChild		第一个子节点，包含文本节点，不用<br>
node.lastChild		最后一个子节点，包含文本节点，不用<br>
node.firstElementChild<br>
node.lastElementChild  	实际开发：用children[  ]<br>
node.nextSibling		下一个兄弟（文字）节点<br>
node.previousSibling	上一个兄弟（文字）节点<br>
node.nextElement	下一个元素兄弟节点<br>
node.previousElement	上一个元素兄弟节点<br>
document.createElement('标签名')<br>
node.appendChild(child) 		子插入到父节点后边中<br>
node.insertBefore(child,指定元素) 	在父节点中的指定元素前插入子<br>
node.removeChild('child')		删除子元素<br>
node.cloneNode()  		克隆完需要添加，参数为空或false，浅拷贝，不复制标签内容；为true深拷贝<br>
添加元素：<br>
创建元素<br>
添加元素</p>
<p>注册事件<br>
①onclick   唯一性，后覆盖前<br>
②addEventListener(事件类型，处理函数，Boolean)	同一事件可注册多个监听器<br>
解绑事件<br>
removeEventListener(事件类型，处理函数，Boolean) 		函数不需要调用（）</p>
<p>Boolean为true--冒泡阶段<br>
Boolean为false--捕获阶段，可选参数，默认为false</p>
<p>DOM事件流<br>
捕获阶段<br>
当前目标阶段<br>
冒泡阶段</p>
<p>事件对象<br>
event是一个事件对象，写在监听函数的小括号里，当形参来看<br>
事件对象只有有了事件才会存在，系统自动创建，不需要传参<br>
事件对象是我们与事件相关的一系列相关数据的集合<br>
事件对象可以自己命名，e/event<br>
window.event--ie678	兼容写法：e = e || window.event</p>
<p>事件对象方法	<br>
e.target	返回触发事件的对象（this返回绑定事件的对象,crrentTarget） 兼容：e.target||e.srcElement<br>
e.type	返回事件类型<br>
e.preventDefault()	阻止默认行为；或者 return falses(后边代码不执行)；</p>
<p>阻止事件冒泡<br>
e.stopPropagation();	e.cancelBubble = true;</p>
<p>事件委托<br>
原理：给父节点添加监听器，利用事件冒泡影响每一个子节点</p>
<p>鼠标事件：<br>
onfocus   获得焦点<br>
onblur     失去焦点</p>
<p>onmouseover  鼠标经过，经过自身、子盒子多次触发<br>
onmouseout    鼠标离开</p>
<p>onnouseenter	鼠标经过，只经过自身盒子触发（不会冒泡）<br>
onmouseleave	鼠标离开（不会冒泡）</p>
<p>contextmenu	取消默认的上下文菜单	e.preventDefault<br>
selectstart	取消选中	配合e.preventDefault</p>
<p>鼠标事件对象<br>
clintX/Y	相对于可视窗口位置<br>
pageX/Y	相对于页面文档位置<br>
screenX/Y	相对于电脑屏幕位置</p>
<p>键盘事件：<br>
onkeyup		按键弹起<br>
onkeydown		按键按下，文字还没有输入，弹起时才输入<br>
onkeypress		按键按下（不识别功能键）<br>
键盘事件对象：<br>
key/keycode 	按了哪个键，up/down不区别大小写，press区分大小写</p>
<p>input事件：<br>
blur		失去焦点<br>
focus	获得焦点<br>
搜索框聚焦：search.focus()</p>
<p>BOM<br>
浏览器对象模型，用于页面交互。window对象是浏览器的顶级对象，具有双重角色<br>
JS访问浏览器窗口的一个接口；<br>
全局对象，定义在全局作用域下的变量、函数都是window对象的属性和方法；			一般省略window</p>
<p>窗口事件<br>
onload	窗口（所有内容）加载事件<br>
DOMContentLoaded	仅DOM加载完毕，不包含图片，flash，css等，快<br>
resize	窗口大小变化<br>
window.innerWidth		当前窗口宽度</p>
<p>定时器<br>
页面中有很多定时器，要给定时器加名字，回调函数   callback</p>
<p>setTimeout(调用函数，[延迟毫秒数])<br>
clearTimeout(定时器名字)		清除定时器</p>
<p>setInterval（调用函数，[间隔毫秒数]）<br>
clearInterval(定时器名字)	注意要在全局定义定时器名字      var timer = null；</p>
<p>缓动效果原理：<br>
（目标值-现在位置）/ 10 做为每次移动距离步长</p>
<p>this指向问题</p>
<p>全局作用域、定时器指向window<br>
指向调用者<br>
构造函数中指向构造函数的实例</p>
<p>同步任务在主线程执行，形成一个执行栈；<br>
异步任务通过回调函数执行，在任务队列（消息队列）执行，有3种：<br>
普通事件 	click、resize<br>
资源加载	load、error<br>
定时器		setInterval、setTimeout</p>
<p>执行机制：<br>
先执行栈中的同步任务<br>
异步任务放在任务队列中<br>
执行栈中的同步任务完事后，系统按次序读取任务队列中的异步任务，进入执行栈</p>
<p>事件循环：主线程不断重复获得任务、执行任务，再获取执行</p>
<p>location对象<br>
href		获取或设置整个URL<br>
host		主机<br>
port		端口号<br>
pathname	路径<br>
search	参数<br>
hash	锚点<br>
location方法<br>
assign（'地址'）	跟href一样，跳转页面，记录浏览历史，实现后退功能<br>
replace（'地址'）	替换当前页面，不保留历史，无法后退<br>
reload（）		重新加载</p>
<p>navigator对象<br>
userAgent	浏览器相关信息</p>
<p>history对象<br>
forward（）	前进<br>
back()		后退<br>
go(参数)		数字表示步数</p>
<p>元素偏移量offset<br>
动态获取元素位置、大小<br>
offsetTop		相对带有定位的父元素上方偏移<br>
offsetLeft		相对带有定位的父元素左方偏移<br>
offsetwidth	元素宽度，包括padding、border、content，不带单位<br>
offsetHeight	元素高度，包括padding、border、content，不带单位<br>
offsetParent	返回带有定位的父级元素，没有返回body												       		（页面距离：e.pageX、e.pageY）<br>
和style区别：<br>
offset获得任意样式，style获得行内样式<br>
offset不带单位，style带单位<br>
style不包含padding、border<br>
offsetwidth只能读，不能写；style.width能读能写<br>
获取用offset，修改用style</p>
<p>元素可视区	client<br>
clientWidth/Height 		自身宽高度，包含padding、content，不包含border<br>
clientTop/Left			返回元素上/左边框大小</p>
<p>立即执行函数<br>
(function() {}) ()<br>
(function() {} ())<br>
自己调用函数<br>
第二个（）看做调用函数，用来传参，独立创建作用域</p>
<p>scroll滚动<br>
scrollWidth/Height		实际宽高度<br>
scrollTop/Left			超出部分的高宽度<br>
onscroll				滚动事件</p>
<p>页面被卷去的头部：window.pageYOffset<br>
左侧：window.pageXOffset</p>
<p>移动端<br>
touch	触屏事件<br>
touchistart	触摸到DOM时<br>
touchmouve	滑动时<br>
touchend		移开时</p>
<p>触摸事件对象	touchEvent<br>
touches	所有正在触摸的手指列表<br>
targetTouches*****	正在触摸当前DOM的手指列表<br>
changedTouches	手指状态变化的列表（手指离开时只有这个）<br>
第一个手指信息：targetTouches[0].pageX</p>
<p>click事件300ms延迟问题解决方案：<br>
禁止缩放	user-scalable = no;<br>
touch事件封装<br>
fastclick插件</p>
<p>本地存储<br>
window.sessionStorage<br>
生命周期为关闭浏览器窗口<br>
在同一个窗口下数据共享<br>
以键值对形式存储<br>
存储数据：sessionStorage.setItem('key',value);<br>
读取数据：sessionStorage.getItem('key');<br>
删除数据：sessionStorage.removeItem('key');<br>
删除所有：sessionStorage.clear();</p>
<p>window.localStorage<br>
生命周期永久生效，除非手动删除<br>
同一浏览器多窗口共享<br>
以键值对形式存储<br>
使用方法一致</p>
<p>jQuery<br>
入口函数<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo>(</mo><mo>)</mo><mrow></mrow><mo>)</mo><mi mathvariant="normal">页</mi><mi mathvariant="normal">面</mi><mi>D</mi><mi>O</mi><mi>M</mi><mi mathvariant="normal">加</mi><mi mathvariant="normal">载</mi><mi mathvariant="normal">完</mi><mi mathvariant="normal">成</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">入</mi><mi mathvariant="normal">口</mi><mi>j</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">伪</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">形</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">只</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi>j</mi><mi>Q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">转</mi><mi mathvariant="normal">化</mi><mi mathvariant="normal">成</mi><mi>D</mi><mi>O</mi><mi>M</mi><mi mathvariant="normal">对</mi><mi mathvariant="normal">象</mi><mi mathvariant="normal">：</mi></mrow><annotation encoding="application/x-tex">(function () {})	页面DOM加载完成的入口
jquery对象：伪数组形式，只能使用jQuery方法
转化成DOM对象：</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mclose">)</span><span class="mord"></span><span class="mclose">)</span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">面</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">加</span><span class="mord cjk_fallback">载</span><span class="mord cjk_fallback">完</span><span class="mord cjk_fallback">成</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">入</span><span class="mord cjk_fallback">口</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">伪</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">只</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">Q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">转</span><span class="mord cjk_fallback">化</span><span class="mord cjk_fallback">成</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">对</span><span class="mord cjk_fallback">象</span><span class="mord cjk_fallback">：</span></span></span></span>('')[0]	$('').get(0)</p>
<p>选择器	$('css选择器')<br>
设置样式	$('css选择器').css('样式','值')		隐式迭代，循环都执行相同操作<br>
样式属性必须加' ',多个样式采用对象形式，可以不加''，值为数字可以不加单位</p>
<p>筛选：<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mo>(</mo><mo mathvariant="normal">′</mo></msup><mi>l</mi><mi>i</mi><mo>:</mo><mi>f</mi><mi>i</mi><mi>s</mi><mi>r</mi><msup><mi>t</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo><mi mathvariant="normal">第</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi></mrow><annotation encoding="application/x-tex">(&#x27;li:fisrt&#x27;)		第一个
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">第</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span></span></span></span>('li:last')		最后一个<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mo>(</mo><mo mathvariant="normal">′</mo></msup><mi>l</mi><mi>i</mi><mo>:</mo><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>)</mo><mi mathvariant="normal">第</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">索</mi><mi mathvariant="normal">引</mi><mi mathvariant="normal">从</mi><mn>0</mn><mi mathvariant="normal">开</mi><mi mathvariant="normal">始</mi></mrow><annotation encoding="application/x-tex">(&#x27;li:index&#x27;)	第index个，索引从0开始
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">第</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">索</span><span class="mord cjk_fallback">引</span><span class="mord cjk_fallback">从</span><span class="mord">0</span><span class="mord cjk_fallback">开</span><span class="mord cjk_fallback">始</span></span></span></span>('li:odd')		奇数个<br>
$('li:even')		偶数个<br>
筛选方法：<br>
parent()			查找父级<br>
children(selector)	最近一级子元素<br>
find(selector)		后代选择器<br>
siblings(selector)	查找兄弟节点，不包括自身<br>
nextAll()			之后所有元素<br>
prevAll()			之前所有元素<br>
eq(index)			选择第index个元素<br>
hasClass()		返回boolean<br>
设置类样式方法：（不影响其他类名）<br>
addClass()		添加类<br>
removeClass()		删除类<br>
toggleClass()		切换类</p>
<p>jQuery动画<br>
show()	显示<br>
hide()	隐藏<br>
toggle()	切换<br>
滑动<br>
slideDown()	下滑<br>
slideUp()		上拉<br>
slideToggle()	切换<br>
事件切换<br>
.hover('经过函数'，'离开函数')	只写一个函数，经过和离开都会触发</p>
<p>停止动画<br>
stop()	必须写到动画前边<br>
淡入淡出<br>
fadeIn(时间)	淡入<br>
fadeOut()		淡出<br>
fadeToggle()	切换<br>
fadeTo(时间，透明度)	<br>
自定义动画animate<br>
需改变样式（必须写）以对象形式传递<br>
speed	（slow、normal、fast）<br>
easing	切换效果，默认swing（linear）<br>
回调函数	动画完成后执行一次<br>
属性操作<br>
获取属性	prop(&quot;属性名&quot;)<br>
设置属性	prop(&quot;属性&quot;,&quot;属性值&quot;)<br>
自定义属性读写	attr()<br>
内存数据	data()	在DOM中看不到<br>
内容文本值<br>
html()		获取元素内容<br>
html(&quot;内容&quot;)	设置元素内容<br>
text()			获取元素文本<br>
text(&quot;内容&quot;)	设置元素文本<br>
val()			获取表单值<br>
val(&quot;内容&quot;)	设置表单值<br>
遍历元素<br>
DOM：each(function(index,domEle))		第一个参数必须是索引号，与数组组合使用<br>
数据：$.each(数据，function（）{})		处理数据<br>
元素操作<br>
创建元素	var li = $(&quot;dom元素&quot;)<br>
添加元素	<br>
内部添加	$(&quot;父级元素&quot;).append(li)	放后边		$(&quot;父级元素&quot;).prepend(li) 放前边<br>
外部添加	element.before/after<br>
删除元素<br>
element.remove()	删自己<br>
element.empty()	删所有子节点<br>
element.html('''')	删所有元素<br>
jQuery尺寸<br>
width/height()	宽高<br>
innerwidth/height()	+padding<br>
outerwidth/height(true)	+padding+border+margin<br>
参数为空，返回数字值；参数为数字，修改为参数值，不必写单位<br>
jQuery位置<br>
offset()		设置或返回相对于文档的偏移坐标，与父级无关，以文档为准<br>
position()		获取相对于定位父级的偏移坐标，不能设置<br>
scrollTop/Left()	滚动被卷去头部/左侧大小<br>
jQuery事件（动态绑定）<br>
多个事件注册	.on({<br>
动作：functio {},<br>
动作：functio {}<br>
})</p>
<p>事件委托<br>
父级.on(&quot;动作&quot;,&quot;子级&quot;,function(){})</p>
<p>事件解绑<br>
off()		参数为空，接触所有事件；参数为事件名，只接触本事件；第2个参数解除事件委托<br>
one()	事件只触发一次</p>
<p>自动触发事件<br>
.click();	不要on<br>
.trigger(&quot;事件&quot;);<br>
.triggerHandler(&quot;事件&quot;)	不会触发默认行为</p>
<p>事件对象<br>
stopPropation()		阻止冒泡<br>
preventDefault()或return false		阻止默认行为</p>
<p>拷贝对象<br>
$.extend([deep],target,obj)	会覆盖原来属性值<br>
deep:true为深拷贝，false为浅拷贝（深拷贝是对象不受影响，浅拷贝是地址受影响）默认为false</p>
<p>多库共存，避免冲突<br>
$=jQuery<br>
var 自定义量 = jQuery.noConflict();</p>
<p>闭包<br>
当函数被定义时，和它周围状态的引用绑定在一起的组合<br>
正常情况下，函数执行完，内部变量会被销毁<br>
闭包存在时，内部函数没有执行完，外部函数的变量不会被销毁<br>
应用：<br>
封装一段代码</p>
<p>ES6<br>
ES5里，以function来划分作用域，大括号{}却限定不了var的作用域，我们把它叫做函数作用域<br>
let<br>
统治整个作用域，不能重复命名<br>
形成块级作用域，不能变量提升，外边读不到<br>
不影响作用域链<br>
const<br>
声明常量，一定要给初始值<br>
一旦声明常量的值就不能更改<br>
不能修改<br>
形成块级作用域，不能变量提升，外边读不到<br>
引用类型变量（数组、对象），指向数据所在的地址，可修改内部属性</p>
<p>解构赋值<br>
对（var let const）变量进行赋值<br>
模式匹配：只要等号两边的模式相同，左边的变量就会被赋予对应的值。<br>
把后续元素当成数组 如果 没有后续元素那么就是空数组<br>
解构失败就是undefined右面的值少<br>
不完全解构右面的值多<br>
不是可遍历的结构，报错<br>
默认赋值，只有右侧的值严格等于undefined的时候才生效。<br>
惰性求值 只有在用到的时候，才会求值</p>
<p>数组扩展<br>
Array.form<br>
定义在构造函数上<br>
任何有length属性的对象，都可以通过Array.from方法转为数组<br>
将数组的空位，转为undefined<br>
如果参数是一个真数组，会返回一个一模一样的新数组（浅拷贝，只复制地址）<br>
第二个参数，对每个元素进行处理然后放入返回的数组之中<br>
let arrayLike = {'0':'a','1':'b','2':'c',length:3};<br>
let arr1 = Array.prototype.slice.call(arrayLike);<br>
let arr2 = Array.from(arrayLike);</p>
<p>Array.of<br>
返回参数值组成的数组。如果没有参数，就返回一个空数组<br>
alert(Array.of(3)); //[3];<br>
alert(Array.of(undefined)) //[undefined];</p>
<p>copyWithin()<br>
将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组<br>
会修改当前数组<br>
实例方法，在数组原型上<br>
接受三个参数<br>
target（必需）：从该位置开始替换数据<br>
start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数<br>
end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数</p>
<p>find()<br>
数组实例方法，用于找出第一个符合条件的数组成员。<br>
参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined</p>
<p>findIndex()<br>
参数为函数<br>
数组实例方法的用法<br>
返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<p>fill()<br>
使用给定值，填充一个数组<br>
接受第二个参数和第三个参数，用于指定填充的起始位置和结束位置</p>
<p>includes()<br>
表示某个数组是否包含给定的值<br>
Array.prototype.includes实例方法返回一个布尔值<br>
和indexOf()的区别是，indexOf内使用严格的运算符，不能判断NaN</p>
<p>flat()<br>
降低数组维度，参数为所降低的数组深度，默认为1<br>
flatMap()<br>
arr.flatMap(item =&gt; [item*10]);  //flat和map的结合</p>
<p>对象的扩展<br>
ES6允许直接写入变量和函数，作为对象的属性和方法。<br>
ES6允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量<br>
Object.is()<br>
用来比较两个值是否严格相等<br>
（ES5比较两个值是否相等，只有两个运算符：相等运算符（<mark>）和严格相等运算符（</mark>=）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。）</p>
<p>Object.assign()<br>
对象合并 (其实是浅拷贝)<br>
var target = {a:1};<br>
var source1 = {b:2};<br>
var source2 = {c:3};<br>
Object.assign(target,source1,source2);<br>
console.log(target);//{a: 1, b: 2, c: 3}</p>
<p>Object.keys<br>
返回一个数组，成员是参数对象自身的属性的键名<br>
var obj = { foo: &quot;bar&quot;, baz: 42 };<br>
Object.keys(obj)<br>
// [&quot;foo&quot;, &quot;baz&quot;]</p>
<p>Object.values<br>
返回一个数组，成员是参数对象自身的属性的键值<br>
var obj = { foo: &quot;bar&quot;, baz: 42 };<br>
Object.values(obj)<br>
// [&quot;bar&quot;, 42]</p>
<p>Object.entries<br>
返回一个数组，成员是参数对象自身的键值对数组<br>
var obj = { foo: 'bar', baz: 42 };<br>
Object.entries(obj)<br>
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</p>
<p>__proto__属性<br>
Object.setPrototypeOf()（写操作）<br>
Object.getPrototypeOf()（读操作）<br>
Object.create()（生成操作）</p>
<p>扩展运算符rest<br>
在函数传参使用时，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。<br>
//浅拷贝数组<br>
var arr = [1,2,3];<br>
var arr1 = [...arr];</p>
<p>字符串扩展<br>
模板字符串<code> </code><br>
解析变量<br>
let name = 'hsx';<br>
let sayname = <code>myname is ${name}</code>;  //myname is hsx</p>
<p>调用函数<br>
function sayHello(){<br>
return 'hello'<br>
}</p>
<p>let sayname = <code>myname is ${sayHello()}</code></p>
<p>startsWith()、endsWith()<br>
startsWith()  是否以参数字符串开头，<br>
endsWith()  	是否以参数字符串结尾<br>
let str = 'Hello hsx!'<br>
let result = str.startsWith('Hello');  //true</p>
<p>repeat()<br>
将原先字符串重复参数次，返回新字符串<br>
let str = 'hsx';<br>
let str2 = str.repeat(2);  //'hsxhsx'</p>
<p>箭头函数<br>
如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分<br>
如果箭头函数的代码块部分多于一条语句，就要使用大括号讲将他们括起来，并且使用return语句返回<br>
由于大括号被解释为代码块 所以如果箭头函数直接返回一个对象的话必须加上一个大括号</p>
<p>箭头函数有几个使用注意点：<br>
（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
<p>Class类<br>
constructor 方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。<br>
类的内部所有定义的方法，都是不可枚举的<br>
类的实例共享一个原型对象</p>
<p>this问题<br>
constructor 里边的this指向new出来的实例<br>
方法里边的this指向这个方法的调用者</p>
<p>Class的继承<br>
super关键字，它指代父类的实例（即父类的this对象）<br>
子类必须在constructor方法最前中调用super方法<br>
因为子类没有自己的this对象，而是继承父类的this对象<br>
class Child extends Parent {<br>
constructor (x) {<br>
var a = super(x);<br>
this.age = 24;<br>
console.log(this.x,this.y);<br>
}<br>
toValue () {<br>
console.log('Child toValue');<br>
}<br>
}</p>
<p>var oC = new Child(1);</p>
<p>Class的静态方法<br>
类相当于实例的原型，所有在类中定义的方法，都会被实例继承。<br>
如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用<br>
静态方法也可以从super对象上调用，子类调用父类的static方法只能在静态函数中调用<br>
不是静态方法，不用static<br>
class Foo2 {<br>
static classMethod() {<br>
return 'Foo2 staic';<br>
}<br>
classMethod2(){<br>
return &quot;不是静态&quot;<br>
}<br>
}</p>
<p>class Bar2 extends Foo2 {<br>
constructor () {<br>
super();<br>
}<br>
static classMethod() {<br>
console.log(super.classMethod() + ', too');<br>
}<br>
say() {<br>
console.log(this.classMethod() + ', say');<br>
}<br>
}</p>
<p>Object.setProperty	设置对象属性<br>
Object.setProperty(目标对象obj,&quot;属性&quot;,配置项{<br>
value：,//属性值<br>
writable:Boolean,//是否可写<br>
enumberable:Boolean,//是否可遍历<br>
configurable:Boolean,//是否可配置<br>
get a(){}<br>
set a(val){}<br>
})</p>
<p>Object.defineProperty	定义对象属性</p>
<p>取值函数（getter）和存值函数（setter）<br>
class A{<br>
constructor(){}<br>
get a(){}<br>
set a(val){}<br>
}</p>
<p>Set<br>
类似于数组，但是成员的值都是唯一的，没有重复的值<br>
Set 本身是一个构造函数，用来生成 Set 数据结构<br>
const s = new Set();</p>
<p>可以接受一个数组（或类似数组的对象）作为参数，用来初始化<br>
去除数组重复成员的方法<br>
[...new Set(array)]</p>
<p>Set 结构的实例有以下属性<br>
Set.prototype.constructor：构造函数，默认就是Set函数。<br>
Set.prototype.size：返回Set实例的成员总数。<br>
add(value)：添加某个值，返回Set结构本身<br>
delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br>
has(value)：返回一个布尔值，表示该值是否为Set的成员。<br>
clear()：清除所有成员，没有返回值。<br>
clear()：清除所有成员，没有返回值。<br>
数组去重<br>
const items = new Set([1, 2, 3, 4, 5]);<br>
const array = Array.from(items);</p>
<p>//from 把①含有length属性②能遍历的伪数组转化为真数组</p>
<p>Set 结构的实例有四个遍历方法，可以用于遍历成员<br>
keys()：返回键名的遍历器<br>
values()：返回键值的遍历器<br>
entries()：返回键值对的遍历器<br>
forEach()：使用回调函数遍历每个成员<br>
由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。<br>
Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。</p>
<p>map<br>
Map结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现<br>
const m = new Map();<br>
const o = {p: 'Hello World'};</p>
<p>m.set(o, 'content')<br>
m.get(o)</p>
<p>Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。<br>
const map = new Map([<br>
['name', '张三'],<br>
['title', 'Author']<br>
]);</p>
<p>Map构造函数接受数组作为参数，实际上执行的是下面的算法。<br>
const items = [<br>
['name', '张三'],<br>
['title', 'Author']<br>
];<br>
const map = new Map();<br>
items.forEach(<br>
([key, value]) =&gt; map.set(key, value)<br>
);</p>
<p>Set和Map都可以用来生成新的 Map。<br>
const set = new Set([<br>
['foo', 1],<br>
['bar', 2]<br>
]);<br>
const m1 = new Map(set);<br>
const m2 = new Map([['baz', 3]]);<br>
const m3 = new Map(m2);</p>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。<br>
const map = new Map();<br>
map<br>
.set(1, 'aaa')<br>
.set(1, 'bbb');</p>
<p>Map 结构的实例有以下属性和操作方法:<br>
（1）size属性<br>
size属性返回 Map 结构的成员总数。<br>
（2）set(key, value)<br>
set方法设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。<br>
set方法返回的是当前的Map对象，因此可以采用链式写法。<br>
（3）get(key)<br>
get方法读取key对应的键值，如果找不到key，返回undefined。<br>
（4）has(key)<br>
has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。<br>
（5）delete(key)<br>
delete方法删除某个键，返回true。如果删除失败，返回false。<br>
（6）clear()<br>
clear方法清除所有成员，没有返回值。</p>
<p>遍历方法<br>
Map 结构原生提供三个遍历器生成函数和一个遍历方法。<br>
keys()：返回键名的遍历器。<br>
values()：返回键值的遍历器。<br>
entries()：返回所有成员的遍历器。<br>
forEach()：遍历 Map 的所有成员。</p>
<p>promise<br>
异步编程<br>
一个对象，从它可以获取异步操作的消息<br>
三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）<br>
Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数<br>
function loadImageAsync(url) {<br>
return new Promise(function(resolve, reject) {<br>
var image = new Image();</p>
<pre><code>image.onload = function() {
  resolve(image);
};

image.onerror = function() {
  reject(new Error('Could not load image at ' + url));
};

image.src = url;
</code></pre>
<p>});<br>
}</p>
<p>技术难点<br>
this<br>
默认绑定：全局调用函数或没有主体调用，this—&gt;window对象（严格模式下，undefined）<br>
（立即执行函数、定时器）<br>
隐藏绑定：一个对象调用自己方法时，this—&gt;自己<br>
（事件绑定）<br>
构造函数绑定：this—&gt;new出来的实例</p>
<p>改变this指向<br>
①call方法<br>
function.call(目标this,参数1,参数2)</p>
<p>call的另个主要作用——继承<br>
function Father (name){<br>
this.name = name;<br>
dowork(){<br>
}<br>
}</p>
<p>function Son (name){<br>
Father.call(this,name)<br>
Father.dowork.call(this);<br>
}<br>
var son = new Son('hsx');</p>
<p>②apply<br>
不同：参数写成数组形式<br>
function.call(目标this,[参数1,参数2])</p>
<p>apply的另个主要作用，处理数组。例如求数组元素最大值<br>
Math.Max.apply(null/null,[arr])</p>
<p>③bind<br>
和call区别：bind不调用函数，返回由其改变this和参数后的函数拷贝<br>
var f = function.bind(目标this,参数1,参数2);<br>
f();</p>
<p>bind的用途2：改变函数this指向，而不要立刻调用函数。<br>
例如：发送验证码按钮，点击后禁用，30秒再启用<br>
var btn = document.getElementByTagName('button');<br>
btn.addEventListener('click',function(){<br>
this.disabled = true;<br>
setTimeOut(function(){<br>
this.disabled = false //此处this指向window<br>
}.bind(this),3000)//此处this指向按钮对象<br>
})</p>
<p>构造函数、实例、原型对象的关系</p>
<p>严格模式<br>
为脚本开启严格模式<br>
所有语句前添加''use strict&quot;<br>
或把整个脚本放到立即执行函数中，再添加<br>
2.为函数开启严格模式<br>
函数代码块前添加''use strict&quot;</p>
<p>严格模式的变化<br>
变量必须先声明再使用<br>
声明的变量不能随便删除<br>
全局作用域下，this不是window而是undefined<br>
构造函数不加new调用，this会报错<br>
函数不能有重复参数<br>
不允许在非代码块内定义函数</p>
<p>图片懒加载<br>
①给鼠标scroll添加滚动事件，然后判断图片到视窗上边的距离小于浏览器窗口显示区高度时，再给图片添加图片src资源</p>
<p>window.innerHeight			获取浏览器窗口显示区高度<br>
getDoundingclientRect.top()	图片到视窗上边的距离</p>
<p>②InterSectionObserver实例<br>
浏览器提供的构造函数<br>
const images = document.querySelectorAll('img');<br>
const observer = new InterSectionObserver(callback);//创建观察者实例</p>
<p>const callback = entries =&gt; {<br>
entries.forEach( entry =&gt;{<br>
if(entry.isIntersecting){  //判断图片是否进入浏览器可视窗口<br>
const image = entry.target;//获取此时的照片<br>
const data_src = image.getAttribute('data_src');<br>
image.setAttribute('src',data.src);//给图片添加url<br>
observer.unobserve('image');//停止观察<br>
}<br>
})<br>
}</p>
<p>images.forEach(image =&gt;{<br>
observer.observe(image);//给图片添加观察者观察事件<br>
})</p>
<p>防抖<br>
将多次操作变成一次<br>
function fangdou (){<br>
let timer = null;<br>
return function(){<br>
clearTimeout(timer);<br>
timer = setTimeout('请求函数','延迟时间')<br>
}<br>
}</p>
<p>注意：此时形成闭包，return后的fun的this指向window，可以使用箭头函数把this绑定给原this</p>
<p>节流<br>
一段时间内只调用一次请求</p>
<p>迭代器</p>
<p>跨域<br>
浏览器的同源策略，协议、主机、端口号都一致才算同源<br>
JSONP<br>
利用<script>的允许请求别处资源的特性，只支持get，不支持post<br>
CORS<br>
在服务器端设置<br>
Access-Control-Allow-Origin:*;</p>
<p>反向代理</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试]]></title>
        <id>https://kingshuxin.github.io/post/mian-shi/</id>
        <link href="https://kingshuxin.github.io/post/mian-shi/">
        </link>
        <updated>2022-09-06T07:37:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="居中">居中</h2>
<pre><code class="language-js">//父元素
{
    display:flex;
}
//子元素
{
    margin:auto;
}
</code></pre>
<h2 id="padding和margin区别">padding和margin区别</h2>
<p>作用对象不同，padding作用于自身，margin作用于外部对象</p>
<h2 id="vw和百分比区别">VW和百分比区别</h2>
<p>百分比有继承；VW不继承，只和设备有关</p>
<h2 id="如何让浏览器支持小字体">如何让浏览器支持小字体</h2>
<pre><code class="language-js">transform: scale(0.5);
-webkit-transform: scale(0.5);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序]]></title>
        <id>https://kingshuxin.github.io/post/wei-xin-xiao-cheng-xu/</id>
        <link href="https://kingshuxin.github.io/post/wei-xin-xiao-cheng-xu/">
        </link>
        <updated>2022-09-05T08:13:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="wxml-模板">WXML 模板</h2>
<p>常用的视图容器类组件:</p>
<p>① view</p>
<ul>
<li>普通视图区域</li>
<li>类似于 HTML 中的 div，是一个块级元素</li>
<li>常用来实现页面的布局效果</li>
</ul>
<p>② scroll-view</p>
<ul>
<li>
<p>可滚动的视图区域</p>
</li>
<li>
<p>常用来实现滚动列表效果</p>
<pre><code class="language-js">//注意：使用竖向滚动时，必须给scroll-view设置固定高度
scroll-y//允许纵向滚动
scroll-x//允许横向滚动
</code></pre>
</li>
</ul>
<p>③text</p>
<ul>
<li>类似于 HTML 中的 span 标签，是一个行内元素</li>
<li>selectable 属性，实现长按选中文本内容的效果</li>
</ul>
<p>④button</p>
<ul>
<li>通过 open-type 属性调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）</li>
</ul>
<pre><code class="language-javascript">type //指定按钮类型
size //控制按钮尺寸
plain //镂空按钮
</code></pre>
<p>⑤image</p>
<ul>
<li>image 组件默认宽度约 300px、高度约 240px</li>
<li>mode 属性用来指定图片的裁剪和缩放模式</li>
</ul>
<p>⑥navigator</p>
<ul>
<li>页面导航组件，类似于 HTML 中的 a 链接</li>
</ul>
<h3 id="wxml-模板语法-数据绑定">WXML 模板语法-<strong>数据绑定</strong></h3>
<ol>
<li><strong>基本原则</strong></li>
</ol>
<p>① 在 data 中定义数据</p>
<p>​	在页面对应的 .js 文件中，把数据定义到 data 对象中即可</p>
<pre><code class="language-javascript">Page({
  data: {
    //字符串类型的数据
    info: 'hsx',
    //数组类型的数据
    msglist: [{msg: 'hsx'},{msg: 'lmx'}]
  },
})
</code></pre>
<p>② 在 WXML 中使用数据</p>
<ul>
<li><strong>动态绑定内容</strong></li>
</ul>
<pre><code class="language-javascript">&lt;text&gt;{{ info }}&lt;/text&gt;
</code></pre>
<ul>
<li><strong>动态绑定属性</strong></li>
</ul>
<pre><code class="language-javascript">&lt;image src=&quot;{{ imgsrc }}&quot;&gt;&lt;/image&gt;
</code></pre>
<h3 id="wxml-模板语法-事件绑定"><strong>WXML 模板语法 - 事件绑定</strong></h3>
<p>①bindtap</p>
<ul>
<li>类似于HTML中的click实践</li>
</ul>
<p><strong>this.setData(dataObject)</strong> 给页面 data 中的数据重新赋值</p>
<pre><code class="language-js">handleClick (){
    this.setData({
      count: this.data.count++
    })
}
</code></pre>
<p>事件传参：</p>
<p><em><em>data-</em> 自定义属性传参</em>*     * 代表的是参数的名字</p>
<p><strong>event.target.dataset.参数名</strong>   即可获取到具体参数的值</p>
<pre><code class="language-js">&lt;button type=&quot;primary&quot; bindtap=&quot;handleClick&quot; data-info=&quot;{{2}}&quot;&gt;点击&lt;/button&gt;
</code></pre>
<pre><code class="language-js">handleClick (event){
    console.log(event.target.dataset.info);
 },
</code></pre>
<p>②bindinput</p>
<ul>
<li>文本框的输入事件</li>
</ul>
<pre><code class="language-javascript">handleInput (e){
    console.log(e.detail.value);//输入后最新的value值
}
</code></pre>
<h3 id="wxml-模板语法-条件渲染"><strong>WXML 模板语法 -</strong> <strong>条件渲染</strong></h3>
<p><strong>1.wx:if、wx:elif 、wx:else</strong></p>
<p>类比if、else if、 else</p>
<p><strong>2. 结合 <block> 使用 wx:if</strong></p>
<p><block> 并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染。</p>
<p><strong>3. hidden</strong></p>
<p>控制元素的显示与隐藏</p>
<h3 id="wxml-模板语法-列表渲染"><strong>WXML 模板语法 -</strong> <strong>列表渲染</strong></h3>
<pre><code class="language-js">&lt;view wx:for=&quot;arr&quot;&gt;
  当前索引是{{index}}
  当前循环项{{item}}
&lt;/view&gt;
</code></pre>
<ul>
<li>
<p>默认情况下，当前循环项的索引用 index 表示；当前循环项用 item 表示。</p>
</li>
<li>
<p>使用 wx:for-index 可以指定当前循环项的索引的变量名</p>
</li>
<li>
<p>使用 wx:for-item 可以指定当前项的变量名</p>
</li>
</ul>
<h2 id="全局配置"><strong>全局配置</strong></h2>
<p>全局配置文件<strong>app.json</strong></p>
<p>① pages  记录当前小程序所有页面的存放路径</p>
<p>② window  全局设置小程序窗口的外观</p>
<ul>
<li>navigationBarTitleText 	导航栏标题文字内容</li>
<li>navigationBarBackgroundColor   导航栏背景颜色</li>
<li>navigationBarTextStyle   导航栏标题颜色，仅支持 black / white</li>
<li>backgroundColor   下拉刷新窗口背景色</li>
<li>backgroundTextStyle   下拉 loading 的样式，仅支持 dark / light</li>
<li>enablePullDownRefresh	是否全局开启下拉刷新</li>
<li>onReachBottomDistance   页面上拉触底事件触发时距页面底部距离，单位为px</li>
</ul>
<p>③ tabBar  设置小程序底部的 tabBar 效果<br>
<img src="https://kingshuxin.github.io/post-images/1663900176949.png" alt="" loading="lazy"><br>
④ style  是否启用新版的组件样式<br>
<img src="https://kingshuxin.github.io/post-images/1662450496627.png" alt="" loading="lazy"></p>
<h2 id="网络数据请求"><strong>网络数据请求</strong></h2>
<ol>
<li>只能请求 HTTPS 类型的接口</li>
<li>必须将接口的域名添加到信任列表中</li>
</ol>
<p><strong>wx.request()</strong>   发起 GET或POST 数据请求</p>
<p>在页面刚加载的时候，自动请求一些初始化的数据。此时需要在页面的 <strong>onLoad</strong> 事件<br>
中调用获取数据的函数</p>
<h2 id="页面导航">页面导航</h2>
<p>小程序中实现页面导航的两种方式：</p>
<ol>
<li>声明式导航<br>
<img src="https://kingshuxin.github.io/post-images/1663900374803.png" alt="" loading="lazy"></li>
</ol>
<ul>
<li>
<p>url 表示要跳转的页面的地址，必须以 / 开头</p>
</li>
<li>
<p>open-type 表示跳转的方式，</p>
<p>①switchTab（导航到 tabBar 页面）</p>
<p>②navigate（导航到非 tabBar 页面，可以省略）</p>
<p>③navigateBack（后退导航）		delta 的值必须是数字，表示要后退的层级</p>
</li>
</ul>
<ol>
<li>编程式导航</li>
</ol>
<p><strong>wx.switchTab(Object object)</strong>   跳转到 tabBar 页面</p>
<ul>
<li>url 需要跳转的 tabBar 页面的路径，路径后不能带参数</li>
<li>success   接口调用成功的回调函数</li>
<li>fail    接口调用失败的回调函数</li>
<li>complete   接口调用结束的回调函数（调用成功、失败都会执行）</li>
</ul>
<p><strong>wx.navigateTo</strong>   跳转到非 tabBar 的页面</p>
<p><strong>wx.navigateBack(Object object)</strong>  返回导航，delta 返回的页面数，如果 delta 大于现有页面数，则返回到首页<br>
<img src="https://kingshuxin.github.io/post-images/1663900509333.png" alt="" loading="lazy"></p>
<h3 id="页面导航-导航传参">页面导航 - 导航传参</h3>
<ol>
<li>声明式导航传参</li>
</ol>
<p><img src="https://kingshuxin.github.io/post-images/1663900543066.png" alt="" loading="lazy">!</p>
<ul>
<li>参数与路径之间使用 ? 分隔</li>
<li>参数键与参数值用 = 相连</li>
<li>不同参数用 &amp; 分隔</li>
</ul>
<p>在 <strong>onLoad 事件</strong>中直接获取到</p>
<figure data-type="image" tabindex="1"><img src="https://kingshuxin.github.io/post-images/1663900576954.png" alt="" loading="lazy"></figure>
<h3 id="页面事件-下拉刷新事件">页面事件 - 下拉刷新事件</h3>
<p><strong>wx.onPullDownRefresh()</strong> **   监听页面的下拉刷新事件</p>
<p><strong>wx.stopPullDownRefresh()</strong>    可以停止当前页面的下拉刷新</p>
<figure data-type="image" tabindex="2"><img src="https://kingshuxin.github.io/post-images/1663900597540.png" alt="" loading="lazy"></figure>
<h3 id="页面事件-上拉触底事件">页面事件 - 上拉触底事件</h3>
<p><strong>wx.onReachBottom()</strong> 函数即可监听当前页面的上拉触底事件</p>
<p><strong>onReachBottomDistance</strong> 	配置上拉触底的距离</p>
<h2 id="生命周期">生命周期</h2>
<p>小程序的应用生命周期函数需要在 app.js 中进行声明</p>
<figure data-type="image" tabindex="3"><img src="https://kingshuxin.github.io/post-images/1663900615712.png" alt="" loading="lazy"></figure>
<p>小程序的页面生命周期函数需要在页面的 .js 文件中进行声明</p>
<figure data-type="image" tabindex="4"><img src="https://kingshuxin.github.io/post-images/1663900632685.png" alt="" loading="lazy"></figure>
<h2 id="wxs-脚本">WXS 脚本</h2>
<p>小程序独有的一套脚本语言，典型应用场景就是“过滤器”</p>
<ol>
<li>内嵌 wxs 脚本</li>
</ol>
<p><img src="https://kingshuxin.github.io/post-images/1663900659579.png" alt="" loading="lazy"><br>
2. 外联的 wxs 脚本</p>
<p>定义：</p>
<figure data-type="image" tabindex="5"><img src="https://kingshuxin.github.io/post-images/1663900683762.png" alt="" loading="lazy"></figure>
<p>使用：<br>
<img src="https://kingshuxin.github.io/post-images/1663900703778.png" alt="" loading="lazy"></p>
<h2 id="自定义组件">自定义组件</h2>
<h3 id="引用组件">引用组件</h3>
<ol>
<li>局部引用<img src="https://kingshuxin.github.io/post-images/1663900732995.png" alt="" loading="lazy"></li>
<li>全局引用<img src="https://kingshuxin.github.io/post-images/1663900760228.png" alt="" loading="lazy"></li>
</ol>
<p><strong>组件和页面的区别</strong></p>
<ul>
<li>组件的 .json 文件中需要声明 &quot;component&quot;: true 属性</li>
<li>组件的 .js 文件中调用的是 Component() 函数</li>
<li>组件的事件处理函数需要定义到 methods 节点中</li>
</ul>
<h3 id="自定义组件-数据-方法和属性">自定义组件 - 数据、方法和属性</h3>
<ol>
<li>
<p>data ——用于组件模板渲染的私有数据</p>
</li>
<li>
<p>methods——事件处理函数和自定义方法</p>
</li>
<li>
<p>properties——接收外界传递到组件中的数据</p>
</li>
</ol>
<p>使用 setData 可修改 properties 的值<br>
<img src="https://kingshuxin.github.io/post-images/1663900781240.png" alt="" loading="lazy"></p>
<h3 id="自定义组件-数据监听器">自定义组件 - 数据监听器</h3>
<p>监听和响应任何属性和数据字段的变化，从而执行特定的操作</p>
<figure data-type="image" tabindex="6"><img src="https://kingshuxin.github.io/post-images/1663900803671.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://kingshuxin.github.io/post-images/1663900822175.png" alt="" loading="lazy"></figure>
<h3 id="自定义组件-纯数据字段">自定义组件 - 纯数据字段</h3>
<p>概念：纯数据字段指的是那些不用于界面渲染的 data 字段。</p>
<p>Component 构造器的 options 节点中，指定 pureDataPattern 为一个正则表达式，字段名符合这个正则<br>
表达式的字段将成为纯数据字段</p>
<figure data-type="image" tabindex="8"><img src="https://kingshuxin.github.io/post-images/1663901012529.png" alt="" loading="lazy"></figure>
<h3 id="自定义组件-组件的生命周期">自定义组件 - 组件的生命周期</h3>
<ol>
<li>created	在组件实例刚刚被创建时执行</li>
<li>attached    在组件实例进入页面节点树时执行</li>
<li>ready   在组件在视图层布局完成后执行</li>
<li>moved   在组件实例被移动到节点树另一个位置时执行</li>
<li>detached   在组件实例被从页面节点树移除时执行</li>
<li>error   每当组件方法抛出错误时执行</li>
</ol>
<p>** lifetimes 节点**<br>
<img src="https://kingshuxin.github.io/post-images/1663901049731.png" alt="" loading="lazy"></p>
<h3 id="自定义组件-组件所在页面的生命周期">自定义组件 - 组件所在页面的生命周期</h3>
<ul>
<li>show   组件所在的页面被展示时执行</li>
<li>hide   组件所在的页面被隐藏时执行</li>
<li>resize   组件所在的页面尺寸变化时执行</li>
</ul>
<p><strong>pageLifetimes 节点</strong></p>
<figure data-type="image" tabindex="9"><img src="https://kingshuxin.github.io/post-images/1663901185178.png" alt="" loading="lazy"></figure>
<h3 id="自定义组件-插槽">自定义组件 - 插槽</h3>
<p>在自定义组件的 wxml 结构中，可以提供一个 <slot> 节点（插槽），用于承载组件使用者提供的 wxml 结构。</p>
<figure data-type="image" tabindex="10"><img src="https://kingshuxin.github.io/post-images/1663901403709.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://kingshuxin.github.io/post-images/1663901428966.png" alt="" loading="lazy"></figure>
<p><strong>多个插槽</strong></p>
<ol>
<li>启用：<img src="https://kingshuxin.github.io/post-images/1663901452032.png" alt="" loading="lazy"></li>
<li>定义<img src="https://kingshuxin.github.io/post-images/1663901469198.png" alt="" loading="lazy"></li>
<li>使用<img src="https://kingshuxin.github.io/post-images/1663901483191.png" alt="" loading="lazy"></li>
</ol>
<h3 id="自定义组件-父子组件之间的通信">自定义组件 - 父子组件之间的通信</h3>
<ol>
<li>属性绑定（父传子）</li>
</ol>
<p><img src="https://kingshuxin.github.io/post-images/1663901533985.png" alt="" loading="lazy"><br>
<img src="https://kingshuxin.github.io/post-images/1663901563774.png" alt="" loading="lazy"></p>
<ol>
<li>事件绑定（子传父）</li>
</ol>
<p>①父组件中定义</p>
<figure data-type="image" tabindex="12"><img src="https://kingshuxin.github.io/post-images/1663901598312.png" alt="" loading="lazy"></figure>
<p>②自定义事件传递给子组件</p>
<figure data-type="image" tabindex="13"><img src="https://kingshuxin.github.io/post-images/1663901658483.png" alt="" loading="lazy"></figure>
<p>③子组件调用 this.triggerEvent(‘自定义事件名称’, { /* 参数对象 */ })</p>
<figure data-type="image" tabindex="14"><img src="https://kingshuxin.github.io/post-images/1663901676681.png" alt="" loading="lazy"></figure>
<p>④父组件e.detail 获取到子组件传递过来的数据</p>
<figure data-type="image" tabindex="15"><img src="https://kingshuxin.github.io/post-images/1663901694206.png" alt="" loading="lazy"></figure>
<ol>
<li>获取组件实例</li>
</ol>
<p>父组件里调用 this.selectComponent(&quot;id或class选择器&quot;) ，获取子组件的实例对象</p>
<h3 id="自定义组件-behaviors">自定义组件 - behaviors</h3>
<p>用于实现组件间代码共享的特性，类似于 Vue.js 中的 “mixins”</p>
<p>①创建 behavior</p>
<figure data-type="image" tabindex="16"><img src="https://kingshuxin.github.io/post-images/1663901711328.png" alt="" loading="lazy"></figure>
<p>②导入并使用 behavior</p>
<figure data-type="image" tabindex="17"><img src="https://kingshuxin.github.io/post-images/1663901727807.png" alt="" loading="lazy"></figure>
<h2 id="全局数据共享">全局数据共享</h2>
<figure data-type="image" tabindex="18"><img src="https://kingshuxin.github.io/post-images/1663901746541.png" alt="" loading="lazy"></figure>
<p><strong>mobx-miniprogram</strong>  创建 Store 实例对象</p>
<p><strong>mobx-miniprogram-bindings</strong>   把 Store 中的共享数据或方法，绑定到组件或页面中使用</p>
<p>①创建 MobX 的 Store 实例</p>
<p><img src="https://kingshuxin.github.io/post-images/1663901766638.png" alt="" loading="lazy"><br>
②将 Store 中的成员绑定到页面中</p>
<p><img src="https://kingshuxin.github.io/post-images/1663901790297.png" alt="" loading="lazy"><br>
③在页面上使用 Store 中的成员</p>
<figure data-type="image" tabindex="19"><img src="https://kingshuxin.github.io/post-images/1663901807197.png" alt="" loading="lazy"></figure>
<p>④将 Store 中的成员绑定到组件中<br>
<img src="https://kingshuxin.github.io/post-images/1663901837742.png" alt="" loading="lazy"></p>
<p>⑤在组件中使用 Store 中的成员</p>
<p><img src="https://kingshuxin.github.io/post-images/1663901861003.png" alt="" loading="lazy">![image-20220905151726601]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[E-charts]]></title>
        <id>https://kingshuxin.github.io/post/e-charts/</id>
        <link href="https://kingshuxin.github.io/post/e-charts/">
        </link>
        <updated>2022-08-31T08:50:06.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>初始化echarts实例对象</li>
</ol>
<pre><code class="language-js">var myChart = echarts.init(document.getElementById('main'));
</code></pre>
<ol start="2">
<li>指定配置项和数据(option)</li>
</ol>
<pre><code class="language-js">var option = {
    xAxis: {
        type: 'category',
        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
        data: [820, 932, 901, 934, 1290, 1330, 1320],
        type: 'line'
    }]
};
</code></pre>
<ol start="3">
<li>将配置项设置给echarts实例对象</li>
</ol>
<pre><code class="language-js">myChart.setOption(option);
</code></pre>
<h3 id="11-echarts-基础配置">11-Echarts-基础配置</h3>
<ul>
<li>
<p>series</p>
<ul>
<li>系列列表。每个系列通过 <code>type</code> 决定自己的图表类型</li>
<li>大白话：图标数据，指定什么类型的图标，可以多个图表重叠。</li>
</ul>
</li>
<li>
<p>xAxis：直角坐标系 grid 中的 x 轴</p>
<ul>
<li>boundaryGap: 坐标轴两边留白策略 true，这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。</li>
</ul>
</li>
<li>
<p>yAxis：直角坐标系 grid 中的 y 轴</p>
</li>
<li>
<p>grid：直角坐标系内绘图网格。</p>
</li>
<li>
<p>title：标题组件</p>
</li>
<li>
<p>tooltip：提示框组件</p>
</li>
<li>
<p>legend：图例组件</p>
</li>
<li>
<p>color：调色盘颜色列表</p>
<p>数据堆叠，同个类目轴上系列配置相同的<code>stack</code>值后 后一个系列的值会在前一个系列的值上相加。</p>
</li>
</ul>
<pre><code class="language-javascript">option = {
    // color设置我们线条的颜色 注意后面是个数组
    color: ['pink', 'red', 'green', 'skyblue'],
    // 设置图表的标题
    title: {
        text: '折线图堆叠123'
    },
    // 图表的提示框组件 
    tooltip: {
        // 触发方式
        trigger: 'axis'
    },
    // 图例组件
    legend: {
       // series里面有了 name值则 legend里面的data可以删掉
    },
    // 网格配置  grid可以控制线形图 柱状图 图表大小
    grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        // 是否显示刻度标签 如果是true 就显示 否则反之
        containLabel: true
    },
    // 工具箱组件  可以另存为图片等功能
    toolbox: {
        feature: {
            saveAsImage: {}
        }
    },
    // 设置x轴的相关配置
    xAxis: {
        type: 'category',
        // 是否让我们的线条和坐标轴有缝隙
        boundaryGap: false,
        data: ['星期一', '周二', '周三', '周四', '周五', '周六', '周日']
    },
     // 设置y轴的相关配置
    yAxis: {
        type: 'value'
    },
    // 系列图表配置 它决定着显示那种类型的图表
    series: [
        {
            name: '邮件营销',
            type: 'line',
           
            data: [120, 132, 101, 134, 90, 230, 210]
        },
        {
            name: '联盟广告',
            type: 'line',

            data: [220, 182, 191, 234, 290, 330, 310]
        },
        {
            name: '视频广告',
            type: 'line',
          
            data: [150, 232, 201, 154, 190, 330, 410]
        },
        {
            name: '直接访问',
            type: 'line',
          
            data: [320, 332, 301, 334, 390, 330, 320]
        }
    ]
};

</code></pre>
<h3 id="12-柱状图图表两大步骤">12- 柱状图图表（两大步骤）</h3>
<ul>
<li>官网找到类似实例， 适当分析，并且引入到HTML页面中</li>
<li>根据需求定制图表</li>
</ul>
<ol>
<li>引入到html页面中</li>
</ol>
<pre><code class="language-javascript">// 柱状图1模块
(function() {
  // 实例化对象
  let myChart = echarts.init(document.querySelector(&quot;.bar .chart&quot;));
  // 指定配置和数据
  let option = {
    color: [&quot;#3398DB&quot;],
    tooltip: {
      trigger: &quot;axis&quot;,
      axisPointer: {
        // 坐标轴指示器，坐标轴触发有效
        type: &quot;shadow&quot; // 默认为直线，可选为：'line' | 'shadow'
      }
    },
    grid: {
      left: &quot;3%&quot;,
      right: &quot;4%&quot;,
      bottom: &quot;3%&quot;,
      containLabel: true
    },
    xAxis: [
      {
        type: &quot;category&quot;,
        data: [&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;],
        axisTick: {
          alignWithLabel: true
        }
      }
    ],
    yAxis: [
      {
        type: &quot;value&quot;
      }
    ],
    series: [
      {
        name: &quot;直接访问&quot;,
        type: &quot;bar&quot;,
        barWidth: &quot;60%&quot;,
        data: [10, 52, 200, 334, 390, 330, 220]
      }
    ]
  };

  // 把配置给实例对象
  myChart.setOption(option);
})();
</code></pre>
<ol start="2">
<li>
<p>根据需求定制</p>
<ul>
<li>
<p>修改图表柱形颜色  #2f89cf</p>
</li>
<li>
<p>修改图表大小  top 为 10px   bottom 为  4%    grid决定我们的柱状图的大小</p>
</li>
</ul>
<pre><code class="language-JavaScript"></code></pre>
</li>
</ol>
<p>color: [&quot;#2f89cf&quot;],<br>
grid: {<br>
left: &quot;0%&quot;,<br>
top: &quot;10px&quot;,<br>
right: &quot;0%&quot;,<br>
bottom: &quot;4%&quot;,<br>
containLabel: true<br>
},</p>
<pre><code>
- X轴相关设置  xAxis
  - 文本颜色设置为   rgba(255,255,255,.6)   字体大小为 12px
  - X轴线的样式 不显示

~~~JavaScript
// 设置x轴标签文字样式
// x轴的文字颜色和大小
     axisLabel: {
       color: &quot;rgba(255,255,255,.6)&quot;,
       fontSize: &quot;12&quot;
     },
//  x轴样式不显示
axisLine: {
    show: false
    // 如果想要设置单独的线条样式 
    // lineStyle: {
    //    color: &quot;rgba(255,255,255,.1)&quot;,
    //    width: 1,
    //    type: &quot;solid&quot;
   }
}
</code></pre>
<ul>
<li>Y 轴相关定制
<ul>
<li>文本颜色设置为   rgba(255,255,255,.6)   字体大小为 12px</li>
<li>Y 轴线条样式 更改为  1像素的  rgba(255,255,255,.1) 边框</li>
<li>分隔线的颜色修饰为  1像素的  rgba(255,255,255,.1)</li>
</ul>
</li>
</ul>
<pre><code class="language-JavaScript">// y 轴文字标签样式
axisLabel: {
   color: &quot;rgba(255,255,255,.6)&quot;,
    fontSize: &quot;12&quot;
},
// y轴线条样式
axisLine: {
   lineStyle: {
      color: &quot;rgba(255,255,255,.1)&quot;,
      // width: 1,
      // type: &quot;solid&quot;
   }
5232},
// y 轴分隔线样式
splitLine: {
 lineStyle: {
    color: &quot;rgba(255,255,255,.1)&quot;
  }
}
</code></pre>
<ul>
<li>修改柱形为圆角以及柱子宽度  series 里面设置</li>
</ul>
<pre><code class="language-JavaScript">series: [
   {
     name: &quot;直接访问&quot;,
     type: &quot;bar&quot;,
     // 修改柱子宽度
     barWidth: &quot;35%&quot;,
     data: [10, 52, 200, 334, 390, 330, 220],
     itemStyle: {
       // 修改柱子圆角
       barBorderRadius: 5
     }
   }
 ]
};
</code></pre>
<ul>
<li>更换对应数据</li>
</ul>
<pre><code class="language-JavaScript">// x轴中更换data数据
data: [ &quot;旅游行业&quot;,&quot;教育培训&quot;, &quot;游戏行业&quot;, &quot;医疗行业&quot;, &quot;电商行业&quot;, &quot;社交行业&quot;, &quot;金融行业&quot; ],
// series 更换数据
data: [200, 300, 300, 900, 1500, 1200, 600]
</code></pre>
<ul>
<li>让图表跟随屏幕自适应</li>
</ul>
<pre><code class="language-javascript">  window.addEventListener(&quot;resize&quot;, function() {
    myChart.resize();
  });
</code></pre>
<h3 id="13-柱状图2定制">13-柱状图2定制</h3>
<ul>
<li>官网找到类似实例， 适当分析，并且引入到HTML页面中</li>
<li>根据需求定制图表</li>
</ul>
<p>需求1： 修改图形大小 grid</p>
<pre><code class="language-javascript">  // 图标位置
    grid: {
      top: &quot;10%&quot;,
      left: &quot;22%&quot;,
      bottom: &quot;10%&quot;
    },
</code></pre>
<p>需求2： 不显示x轴</p>
<pre><code class="language-javascript">   xAxis: {
      show: false
    },
</code></pre>
<p>需求3： y轴相关定制</p>
<ul>
<li>不显示y轴线和相关刻度</li>
</ul>
<pre><code class="language-javascript">//不显示y轴线条
axisLine: {
    show: false
        },
// 不显示刻度
axisTick: {
   show: false
},
</code></pre>
<ul>
<li>y轴文字的颜色设置为白色</li>
</ul>
<pre><code class="language-javascript">   axisLabel: {
          color: &quot;#fff&quot;
   },
</code></pre>
<p>需求4： 修改第一组柱子相关样式（条状）</p>
<pre><code class="language-javascript">name: &quot;条&quot;,
// 柱子之间的距离
barCategoryGap: 50,
//柱子的宽度
barWidth: 10,
// 柱子设为圆角
itemStyle: {
    normal: {
      barBorderRadius: 20,       
    }
},
</code></pre>
<ul>
<li>设置第一组柱子内百分比显示数据</li>
</ul>
<pre><code class="language-javascript">// 图形上的文本标签
label: {
    normal: {
         show: true,
         // 图形内显示
         position: &quot;inside&quot;,
         // 文字的显示格式
         formatter: &quot;{c}%&quot;
     }
},
</code></pre>
<ul>
<li>设置第一组柱子不同颜色</li>
</ul>
<pre><code class="language-javascript">// 声明颜色数组
var myColor = [&quot;#1089E7&quot;, &quot;#F57474&quot;, &quot;#56D0E3&quot;, &quot;#F8B448&quot;, &quot;#8B78F6&quot;];
// 2. 给 itemStyle  里面的color 属性设置一个 返回值函数
  itemStyle: {
          normal: {
            barBorderRadius: 20,  
            // params 传进来的是柱子对象
            console.log(params);
            // dataIndex 是当前柱子的索引号
            return myColor[params.dataIndex];
          }
         
},
</code></pre>
<p>需求5： 修改第二组柱子的相关配置（框状）</p>
<pre><code class="language-javascript">  	    name: &quot;框&quot;,
        type: &quot;bar&quot;,
        barCategoryGap: 50,
        barWidth: 15,
        itemStyle: {
            color: &quot;none&quot;,
            borderColor: &quot;#00c1de&quot;,
            borderWidth: 3,
            barBorderRadius: 15
        },
        data: [19325, 23438, 31000, 121594, 134141, 681807]
      }
</code></pre>
<p>需求6： 给y轴添加第二组数据</p>
<pre><code class="language-javascript">yAxis: [
      {
      type: &quot;category&quot;,
      data: [&quot;印尼&quot;, &quot;美国&quot;, &quot;印度&quot;, &quot;中国&quot;, &quot;世界人口(万)&quot;],
      // 不显示y轴的线
      axisLine: {
        show: false
      },
      // 不显示刻度
      axisTick: {
        show: false
      },
      // 把刻度标签里面的文字颜色设置为白色
      axisLabel: {
        color: &quot;#fff&quot;
      }
    },
      {
        show: true,
        data: [702, 350, 610, 793, 664],
           // 不显示y轴的线
      axisLine: {
        show: false
      },
      // 不显示刻度
      axisTick: {
        show: false
      },
        axisLabel: {
          textStyle: {
            fontSize: 12,
            color: &quot;#fff&quot;
          }
        }
      }
    ],
</code></pre>
<p>需求7： 设置两组柱子层叠以及更换数据</p>
<pre><code class="language-javascript">// 给series  第一个对象里面的 添加 
yAxisIndex: 0,
// 给series  第二个对象里面的 添加 
yAxisIndex: 1,
// series 第一个对象里面的data
data: [70, 34, 60, 78, 69],
// series 第二个对象里面的data
data: [100, 100, 100, 100, 100],
// y轴更换第一个对象更换data数据
data: [&quot;HTML5&quot;, &quot;CSS3&quot;, &quot;javascript&quot;, &quot;VUE&quot;, &quot;NODE&quot;],
// y轴更换第二个对象更换data数据
data:[702, 350, 610, 793, 664],
</code></pre>
<p>完整代码：</p>
<pre><code class="language-javascript">// 柱状图2
(function() {
  var myColor = [&quot;#1089E7&quot;, &quot;#F57474&quot;, &quot;#56D0E3&quot;, &quot;#F8B448&quot;, &quot;#8B78F6&quot;];
  // 1. 实例化对象
  var myChart = echarts.init(document.querySelector(&quot;.bar2 .chart&quot;));
  // 2. 指定配置和数据
  var option = {
    grid: {
      top: &quot;10%&quot;,
      left: &quot;22%&quot;,
      bottom: &quot;10%&quot;
      // containLabel: true
    },
    // 不显示x轴的相关信息
    xAxis: {
      show: false
    },
    yAxis: [
      {
        type: &quot;category&quot;,
        inverse: true,
        data: [&quot;HTML5&quot;, &quot;CSS3&quot;, &quot;javascript&quot;, &quot;VUE&quot;, &quot;NODE&quot;],
        // 不显示y轴的线
        axisLine: {
          show: false
        },
        // 不显示刻度
        axisTick: {
          show: false
        },
        // 把刻度标签里面的文字颜色设置为白色
        axisLabel: {
          color: &quot;#fff&quot;
        }
      },
      {
        data: [702, 350, 610, 793, 664],
        inverse: true,
        // 不显示y轴的线
        axisLine: {
          show: false
        },
        // 不显示刻度
        axisTick: {
          show: false
        },
        // 把刻度标签里面的文字颜色设置为白色
        axisLabel: {
          color: &quot;#fff&quot;
        }
      }
    ],
    series: [
      {
        name: &quot;条&quot;,
        type: &quot;bar&quot;,
        data: [70, 34, 60, 78, 69],
        yAxisIndex: 0,
        // 修改第一组柱子的圆角
        itemStyle: {
          barBorderRadius: 20,
          // 此时的color 可以修改柱子的颜色
          color: function(params) {
            // params 传进来的是柱子对象
            console.log(params);
            // dataIndex 是当前柱子的索引号
            return myColor[params.dataIndex];
          }
        },
        // 柱子之间的距离
        barCategoryGap: 50,
        //柱子的宽度
        barWidth: 10,
        // 显示柱子内的文字
        label: {
          show: true,
          position: &quot;inside&quot;,
          // {c} 会自动的解析为 数据  data里面的数据
          formatter: &quot;{c}%&quot;
        }
      },
      {
        name: &quot;框&quot;,
        type: &quot;bar&quot;,
        barCategoryGap: 50,
        barWidth: 15,
        yAxisIndex: 1,
        data: [100, 100, 100, 100, 100],
        itemStyle: {
          color: &quot;none&quot;,
          borderColor: &quot;#00c1de&quot;,
          borderWidth: 3,
          barBorderRadius: 15
        }
      }
    ]
  };

  // 3. 把配置给实例对象
  myChart.setOption(option);
})();

</code></pre>
<h3 id="14-折线图1-人员变化模块制作">14-折线图1 人员变化模块制作</h3>
<ul>
<li>官网找到类似实例， 适当分析，并且引入到HTML页面中</li>
<li>根据需求定制图表</li>
</ul>
<p>需求1： 修改折线图大小，显示边框设置颜色：#012f4a，并且显示刻度标签。</p>
<pre><code class="language-js">    // 设置网格样式
    grid: { 
      top: '20%',
      left: '3%',
      right: '4%',
      bottom: '3%',
      show: true,// 显示边框
      borderColor: '#012f4a',// 边框颜色
      containLabel: true // 包含刻度文字在内
    },
</code></pre>
<p>需求2： 修改图例组件中的文字颜色 #4c9bfd， 距离右侧 right 为 10%</p>
<pre><code class="language-javascript"> // 图例组件
    legend: {
      textStyle: {
        color: '#4c9bfd' // 图例文字颜色
      },
      right: '10%' // 距离右边10%
    },
</code></pre>
<p>需求3： x轴相关配置</p>
<ul>
<li>刻度去除</li>
<li>x轴刻度标签字体颜色：#4c9bfd</li>
<li>剔除x坐标轴线颜色（将来使用Y轴分割线)</li>
<li>轴两端是不需要内间距 boundaryGap</li>
</ul>
<pre><code class="language-javascript">    xAxis: {
      type: 'category',
      data: [&quot;周一&quot;, &quot;周二&quot;],
	  axisTick: {
         show: false // 去除刻度线
       },
       axisLabel: {
         color: '#4c9bfd' // 文本颜色
       },
       axisLine: {
         show: false // 去除轴线
       },
       boundaryGap: false  // 去除轴内间距
    },
</code></pre>
<p>需求4： y轴的定制</p>
<ul>
<li>刻度去除</li>
<li>字体颜色：#4c9bfd</li>
<li>分割线颜色：#012f4a</li>
</ul>
<pre><code class="language-javascript">    yAxis: {
      type: 'value',
      axisTick: {
        show: false  // 去除刻度
      },
      axisLabel: {
        color: '#4c9bfd' // 文字颜色
      },
      splitLine: {
        lineStyle: {
          color: '#012f4a' // 分割线颜色
        }
      }
    },
</code></pre>
<p>需求5： 两条线形图定制</p>
<ul>
<li>颜色分别：#00f2f1  #ed3f35</li>
<li>把折线修饰为圆滑 series 数据中添加 smooth 为 true</li>
</ul>
<pre><code class="language-js">    color: ['#00f2f1', '#ed3f35'],
	series: [{
      name:'新增粉丝',
      data: [820, 932, 901, 934, 1290, 1330, 1320],
      type: 'line',
      // 折线修饰为圆滑
      smooth: true,
      },{
      name:'新增游客',
      data: [100, 331, 200, 123, 233, 543, 400],
      type: 'line',
      smooth: true,
    }]
</code></pre>
<p>需求6： 配置数据</p>
<pre><code class="language-js">// x轴的文字
xAxis: {
  type: 'category',
  data: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
</code></pre>
<pre><code class="language-js">// 图标数据
    series: [{
      name:'新增粉丝',
      data:  [24, 40, 101, 134, 90, 230, 210, 230, 120, 230, 210, 120],
      type: 'line',
      smooth: true
    },{
      name:'新增游客',
      data: [40, 64, 191, 324, 290, 330, 310, 213, 180, 200, 180, 79],     
      type: 'line',
      smooth: true
      }
    }]
</code></pre>
<p>需求7： 新增需求  点击 2020年   2021年 数据发生变化</p>
<p>以下是后台送过来数据（ajax请求过来的）</p>
<pre><code class="language-javascript"> var yearData = [
      {
        year: '2020',  // 年份
        data: [  // 两个数组是因为有两条线
             [24, 40, 101, 134, 90, 230, 210, 230, 120, 230, 210, 120],
             [40, 64, 191, 324, 290, 330, 310, 213, 180, 200, 180, 79]
          ]
      },
      {
        year: '2021',  // 年份
        data: [  // 两个数组是因为有两条线
             [123, 175, 112, 197, 121, 67, 98, 21, 43, 64, 76, 38],
     		[143, 131, 165, 123, 178, 21, 82, 64, 43, 60, 19, 34]
          ]
      }
     ];
</code></pre>
<ul>
<li>tab栏切换事件</li>
<li>点击2020按钮   需要把 series 第一个对象里面的data  换成  2020年对象里面data[0]</li>
<li>点击2020按钮   需要把 series 第二个对象里面的data  换成  2020年对象里面data[1]</li>
<li>2021 按钮同样道理</li>
</ul>
<p>完整代码：</p>
<pre><code class="language-javascript">// 折线图1模块制作
(function() {
  var yearData = [
    {
      year: &quot;2020&quot;, // 年份
      data: [
        // 两个数组是因为有两条线
        [24, 40, 101, 134, 90, 230, 210, 230, 120, 230, 210, 120],
        [40, 64, 191, 324, 290, 330, 310, 213, 180, 200, 180, 79]
      ]
    },
    {
      year: &quot;2021&quot;, // 年份
      data: [
        // 两个数组是因为有两条线
        [123, 175, 112, 197, 121, 67, 98, 21, 43, 64, 76, 38],
        [143, 131, 165, 123, 178, 21, 82, 64, 43, 60, 19, 34]
      ]
    }
  ];
  // 1. 实例化对象
  var myChart = echarts.init(document.querySelector(&quot;.line .chart&quot;));
  // 2.指定配置
  var option = {
    // 通过这个color修改两条线的颜色
    color: [&quot;#00f2f1&quot;, &quot;#ed3f35&quot;],
    tooltip: {
      trigger: &quot;axis&quot;
    },
    legend: {
      // 如果series 对象有name 值，则 legend可以不用写data
      // 修改图例组件 文字颜色
      textStyle: {
        color: &quot;#4c9bfd&quot;
      },
      // 这个10% 必须加引号
      right: &quot;10%&quot;
    },
    grid: {
      top: &quot;20%&quot;,
      left: &quot;3%&quot;,
      right: &quot;4%&quot;,
      bottom: &quot;3%&quot;,
      show: true, // 显示边框
      borderColor: &quot;#012f4a&quot;, // 边框颜色
      containLabel: true // 包含刻度文字在内
    },

    xAxis: {
      type: &quot;category&quot;,
      boundaryGap: false,
      data: [
        &quot;1月&quot;,
        &quot;2月&quot;,
        &quot;3月&quot;,
        &quot;4月&quot;,
        &quot;5月&quot;,
        &quot;6月&quot;,
        &quot;7月&quot;,
        &quot;8月&quot;,
        &quot;9月&quot;,
        &quot;10月&quot;,
        &quot;11月&quot;,
        &quot;12月&quot;
      ],
      axisTick: {
        show: false // 去除刻度线
      },
      axisLabel: {
        color: &quot;#4c9bfd&quot; // 文本颜色
      },
      axisLine: {
        show: false // 去除轴线
      }
    },
    yAxis: {
      type: &quot;value&quot;,
      axisTick: {
        show: false // 去除刻度线
      },
      axisLabel: {
        color: &quot;#4c9bfd&quot; // 文本颜色
      },
      axisLine: {
        show: false // 去除轴线
      },
      splitLine: {
        lineStyle: {
          color: &quot;#012f4a&quot; // 分割线颜色
        }
      }
    },
    series: [
      {
        name: &quot;新增粉丝&quot;,
        type: &quot;line&quot;,
        // true 可以让我们的折线显示带有弧度
        smooth: true,
        data: yearData[0].data[0]
      },
      {
        name: &quot;新增游客&quot;,
        type: &quot;line&quot;,
        smooth: true,
        data: yearData[0].data[1]
      }
    ]
  };

  // 3. 把配置给实例对象
  myChart.setOption(option);
  // 4. 让图表跟随屏幕自动的去适应
  window.addEventListener(&quot;resize&quot;, function() {
    myChart.resize();
  });

  // 5.点击切换效果
  $(&quot;.line h2&quot;).on(&quot;click&quot;, &quot;a&quot;, function() {
    // alert(1);
    // console.log($(this).index());
    // 点击 a 之后 根据当前a的索引号 找到对应的 yearData的相关对象
    // console.log(yearData[$(this).index()]);
    var obj = yearData[$(this).index()];
    option.series[0].data = obj.data[0];
    option.series[1].data = obj.data[1];
    // 需要重新渲染
    myChart.setOption(option);
  });
})();
</code></pre>
<h3 id="15-折线图2-播放量模块制作">15-折线图2 播放量模块制作</h3>
<ul>
<li>官网找到类似实例， 适当分析，并且引入到HTML页面中</li>
<li>根据需求定制图表</li>
</ul>
<p>需求1： 更换图例组件文字颜色 rgba(255,255,255,.5)  文字大小为12</p>
<pre><code class="language-javascript"> legend: {
      top: &quot;0%&quot;,
      textStyle: {
        color: &quot;rgba(255,255,255,.5)&quot;,
        fontSize: &quot;12&quot;
      }
},
</code></pre>
<p>需求2： 修改图表大小</p>
<pre><code class="language-javascript">grid: {
      left: &quot;10&quot;,
      top: &quot;30&quot;,
      right: &quot;10&quot;,
      bottom: &quot;10&quot;,
      containLabel: true
    },
</code></pre>
<p>需求3： 修改x轴相关配置</p>
<ul>
<li>修改文本颜色为rgba(255,255,255,.6)  文字大小为 12</li>
<li>x轴线的颜色为   rgba(255,255,255,.2)</li>
</ul>
<pre><code class="language-javascript">     // 文本颜色为rgba(255,255,255,.6)  文字大小为 12
     axisLabel: {
          textStyle: {
            color: &quot;rgba(255,255,255,.6)&quot;,
            fontSize: 12
          }
        },
         // x轴线的颜色为   rgba(255,255,255,.2)
        axisLine: {
          lineStyle: {
            color: &quot;rgba(255,255,255,.2)&quot;
          }
        },
</code></pre>
<p>需求4： 修改y轴的相关配置</p>
<pre><code class="language-javascript">        axisTick: { show: false },
        axisLine: {
          lineStyle: {
            color: &quot;rgba(255,255,255,.1)&quot;
          }
        },
        axisLabel: {
          textStyle: {
            color: &quot;rgba(255,255,255,.6)&quot;,
            fontSize: 12
          }
        },
	   // 修改分割线的颜色
        splitLine: {
          lineStyle: {
            color: &quot;rgba(255,255,255,.1)&quot;
          }
        }
      
</code></pre>
<p>需求5： 修改两个线模块配置(注意在series 里面定制)</p>
<pre><code class="language-javascript">       //第一条 线是圆滑
       smooth: true,
        // 单独修改线的样式
        lineStyle: {
            color: &quot;#0184d5&quot;,
            width: 2 
        },
         // 填充区域
        areaStyle: {
              // 渐变色，只需要复制即可
            color: new echarts.graphic.LinearGradient(
              0,
              0,
              0,
              1,
              [
                {
                  offset: 0,
                  color: &quot;rgba(1, 132, 213, 0.4)&quot;   // 渐变色的起始颜色
                },
                {
                  offset: 0.8,
                  color: &quot;rgba(1, 132, 213, 0.1)&quot;   // 渐变线的结束颜色
                }
              ],
              false
            ),
            shadowColor: &quot;rgba(0, 0, 0, 0.1)&quot;
        },
        // 设置拐点 小圆点
        symbol: &quot;circle&quot;,
        // 拐点大小
        symbolSize: 8,
        // 设置拐点颜色以及边框
       itemStyle: {
            color: &quot;#0184d5&quot;,
            borderColor: &quot;rgba(221, 220, 107, .1)&quot;,
            borderWidth: 12
        },
        // 开始不显示拐点， 鼠标经过显示
        showSymbol: false,
</code></pre>
<pre><code class="language-javascript">       name: &quot;转发量&quot;,
        type: &quot;line&quot;,
        smooth: true,
        lineStyle: {
          normal: {
            color: &quot;#00d887&quot;,
            width: 2
          }
         },
         areaStyle: {
          normal: {
            color: new echarts.graphic.LinearGradient(
              0,
              0,
              0,
              1,
              [
                {
                  offset: 0,
                  color: &quot;rgba(0, 216, 135, 0.4)&quot;
                },
                {
                  offset: 0.8,
                  color: &quot;rgba(0, 216, 135, 0.1)&quot;
                }
              ],
              false
            ),
            shadowColor: &quot;rgba(0, 0, 0, 0.1)&quot;
          }
        },
        // 设置拐点 小圆点
        symbol: &quot;circle&quot;,
        // 拐点大小
        symbolSize: 5,
        // 设置拐点颜色以及边框
         itemStyle: {
            color: &quot;#00d887&quot;,
            borderColor: &quot;rgba(221, 220, 107, .1)&quot;,
            borderWidth: 12
        },
        // 开始不显示拐点， 鼠标经过显示
        showSymbol: false,
</code></pre>
<p>需求6： 更换数据</p>
<pre><code class="language-javascript">// x轴更换数据
data: [ &quot;01&quot;,&quot;02&quot;,&quot;03&quot;,&quot;04&quot;,&quot;05&quot;,&quot;06&quot;,&quot;07&quot;,&quot;08&quot;,&quot;09&quot;,&quot;10&quot;,&quot;11&quot;,&quot;12&quot;,&quot;13&quot;,&quot;14&quot;,&quot;15&quot;,&quot;16&quot;,&quot;17&quot;,&quot;18&quot;,&quot;19&quot;,&quot;20&quot;,&quot;21&quot;,&quot;22&quot;,&quot;23&quot;,&quot;24&quot;,&quot;25&quot;,&quot;26&quot;,&quot;26&quot;,&quot;28&quot;,&quot;29&quot;,&quot;30&quot;],
// series  第一个对象data数据
 data: [ 30, 40, 30, 40,30, 40, 30,60,20, 40, 30, 40, 30, 40,30, 40, 30,60,20, 40, 30, 40, 30, 40,30, 40, 20,60,50, 40],
// series  第二个对象data数据
 data: [ 130, 10, 20, 40,30, 40, 80,60,20, 40, 90, 40,20, 140,30, 40, 130,20,20, 40, 80, 70, 30, 40,30, 120, 20,99,50, 20],

</code></pre>
<h3 id="16-饼形图-1年龄分布模块制作">16-饼形图 1年龄分布模块制作</h3>
<ul>
<li>官网找到类似实例， 适当分析，并且引入到HTML页面中</li>
<li>根据需求定制图表</li>
</ul>
<p>定制图表需求1：</p>
<ul>
<li>修改图例组件在底部并且居中显示。</li>
<li>每个小图标的宽度和高度修改为 10px</li>
<li>文字大小为12 颜色  rgba(255,255,255,.5)</li>
</ul>
<pre><code class="language-javascript"> legend: {
      // 距离底部为0%
      bottom: &quot;0%&quot;,
      // 小图标的宽度和高度
      itemWidth: 10,
      itemHeight: 10,
      data: ['直接访问', '邮件营销', '联盟广告', '视频广告', '搜索引擎'],
      // 修改图例组件的文字为 12px
      textStyle: {
        color: &quot;rgba(255,255,255,.5)&quot;,
        fontSize: &quot;12&quot;
      }
 },
</code></pre>
<p>定制需求2：</p>
<ul>
<li>修改水平居中 垂直居中</li>
<li>修改内圆半径和外圆半径为    [&quot;40%&quot;, &quot;60%&quot;]   pink老师友情提示，带有直角坐标系的比如折线图柱状图是 grid修改图形大小，而我们饼形图是通过 radius 修改大小</li>
</ul>
<pre><code class="language-javascript">series: [
      {
        name: &quot;年龄分布&quot;,
        type: &quot;pie&quot;,
        // 设置饼形图在容器中的位置
        center: [&quot;50%&quot;, &quot;50%&quot;],
        //  修改内圆半径和外圆半径为  百分比是相对于容器宽度来说的
        radius: [&quot;40%&quot;, &quot;60%&quot;],
        // 不显示标签文字
        label: { show: false },
        // 不显示连接线
        labelLine: { show: false },
      }
    ]
</code></pre>
<p>定制需求3：更换数据</p>
<pre><code class="language-javascript">// legend 中的data  可省略
data: [&quot;0岁以下&quot;, &quot;20-29岁&quot;, &quot;30-39岁&quot;, &quot;40-49岁&quot;, &quot;50岁以上&quot;],
//  series 中的数据
 data: [
          { value: 1, name: &quot;0岁以下&quot; },
          { value: 4, name: &quot;20-29岁&quot; },
          { value: 2, name: &quot;30-39岁&quot; },
          { value: 2, name: &quot;40-49岁&quot; },
          { value: 1, name: &quot;50岁以上&quot; }
 ] ,
</code></pre>
<p>定制需求4： 更换颜色</p>
<pre><code class="language-javascript">color: [
          &quot;#065aab&quot;,
          &quot;#066eab&quot;,
          &quot;#0682ab&quot;,
          &quot;#0696ab&quot;,
          &quot;#06a0ab&quot;,
        ],
</code></pre>
<pre><code class="language-javascript"> // 4. 让图表跟随屏幕自动的去适应
  window.addEventListener(&quot;resize&quot;, function() {
    myChart.resize();
  });
</code></pre>
<h3 id="17-饼形图2-地区分布模块制作南丁格尔玫瑰图">17-饼形图2 地区分布模块制作（南丁格尔玫瑰图）</h3>
<ul>
<li>官网找到类似实例， 适当分析，并且引入到HTML页面中</li>
<li>根据需求定制图表</li>
</ul>
<p>第二步：按照需求定制</p>
<ul>
<li>需求1：颜色设置</li>
</ul>
<pre><code class="language-js">color: ['#006cff', '#60cda0', '#ed8884', '#ff9f7f', '#0096ff', '#9fe6b8', '#32c5e9', '#1d9dff'],
</code></pre>
<ul>
<li>需求2：修改饼形图大小 ( series对象)</li>
</ul>
<pre><code class="language-javascript">radius: ['10%', '70%'],
</code></pre>
<ul>
<li>需求3： 把饼形图的显示模式改为 半径模式</li>
</ul>
<pre><code class="language-javascript"> roseType: &quot;radius&quot;,
</code></pre>
<ul>
<li>需求4：数据使用更换（series对象 里面 data对象）</li>
</ul>
<pre><code class="language-js">          { value: 20, name: '云南' },
          { value: 26, name: '北京' },
          { value: 24, name: '山东' },
          { value: 25, name: '河北' },
          { value: 20, name: '江苏' },
          { value: 25, name: '浙江' },
          { value: 30, name: '四川' },
          { value: 42, name: '湖北' }
</code></pre>
<ul>
<li>
<p>需求5：字体略小些  10 px ( series对象里面设置 )</p>
<p>饼图图形上的文本标签可以控制饼形图的文字的一些样式。   label 对象设置</p>
</li>
</ul>
<pre><code class="language-javascript">series: [
      {
        name: &quot;面积模式&quot;,
        type: &quot;pie&quot;,
        radius: [30, 110],
        center: [&quot;50%&quot;, &quot;50%&quot;],
        roseType: &quot;radius&quot;,
        // 文本标签控制饼形图文字的相关样式， 注意它是一个对象
        label: {
          fontSize: 10
        },
      }
    ]
  };
</code></pre>
<ul>
<li>需求6：防止缩放的时候，引导线过长。引导线略短些   (series对象里面的  labelLine  对象设置  )
<ul>
<li>连接图表 6 px</li>
<li>连接文字 8 px</li>
</ul>
</li>
</ul>
<pre><code class="language-diff">+        // 文字调整
+        label:{
+          fontSize: 10
+        },
+        // 引导线调整
+        labelLine: {
+          // 连接扇形图线长
+          length: 6,
+          // 连接文字线长
+          length2: 8
+        } 
+      }
+    ],

</code></pre>
<ul>
<li>需求6：浏览器缩放的时候，图表跟着自动适配。</li>
</ul>
<pre><code class="language-javascript">// 监听浏览器缩放，图表对象调用缩放resize函数
window.addEventListener(&quot;resize&quot;, function() {
    myChart.resize();
  });
</code></pre>
<h3 id="18-echarts-社区介绍">18-Echarts-社区介绍</h3>
<blockquote>
<p><a href="https://gallery.echartsjs.com/explore.html#sort=rank~timeframe=all~author=all">社区</a>就是一些，活跃的echart使用者，交流和贡献定制好的图表的地方。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="docs/media/1576664444951.png" alt="1576664444951" loading="lazy"></figure>
<ul>
<li>在这里可以找到一些基于echart的高度定制好的图表，相当于基于jquery开发的插件，这里是基于echarts开发的第三方的图表。</li>
</ul>
<h3 id="19-echarts-map使用扩展">19-Echarts-map使用（扩展）</h3>
<p>参考社区的例子：https://gallery.echartsjs.com/editor.html?c=x0-ExSkZDM  (模拟飞机航线)</p>
<p>实现步骤：</p>
<ul>
<li>第一需要下载china.js提供中国地图的js文件</li>
<li>第二个因为里面代码比较多，我们新建一个新的js文件 myMap.js 引入</li>
<li>使用社区提供的配置即可。</li>
</ul>
<p>需要修改：</p>
<ul>
<li>去掉标题组件</li>
<li>去掉背景颜色</li>
<li>修改地图省份背景  #142957  areaColor 里面做修改</li>
<li>地图放大通过  zoom   设置为1.2即可</li>
</ul>
<pre><code class="language-javascript">    geo: {
      map: 'china',
      zoom: 1.2,
      label: {
        emphasis: {
          show: false
        }
      },
      roam: false,
      itemStyle: {
        normal: {
          areaColor: '#142957',
          borderColor: '#0692a4'
        },
        emphasis: {
          areaColor: '#0b1c2d'
        }
      }
    },
</code></pre>
<p>总结：这例子是扩展案例，大家以后可以多看看社区里面的案例。</p>
<h3 id="20-最后约束缩放">20- 最后约束缩放</h3>
<pre><code class="language-css">/* 约束屏幕尺寸 */
@media screen and (max-width: 1024px) {
  html {
    font-size: 42px !important;
  }
}
@media screen and (min-width: 1920px) {
  html {
    font-size: 80px !important;
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue]]></title>
        <id>https://kingshuxin.github.io/post/vue/</id>
        <link href="https://kingshuxin.github.io/post/vue/">
        </link>
        <updated>2022-08-30T15:20:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue">vue</h1>
<h2 id="基础">基础</h2>
<p>初识Vue：</p>
<p>​        1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</p>
<p>​        2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</p>
<p>​        3.root容器里的代码被称为【Vue模板】；</p>
<p>​        4.Vue实例和容器是一一对应的；</p>
<p>​        5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；</p>
<p>​        6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</p>
<p>​        7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p>
<p>注意区分：js表达式 和 js代码(语句)</p>
<p>​            1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方</p>
<pre><code class="language-js"> (1). a

​(2). a+b                  

​(3). demo(1)                  

​(4). x === y ? 'a' : 'b                  
</code></pre>
<p>​            2.js代码(语句)</p>
<pre><code class="language-js">(1). if(){}

​(2). for(){}
</code></pre>
<p>Vue模板语法有2大类：</p>
<p>​          1.插值语法：</p>
<p>​              功能：用于解析标签体内容。</p>
<p>​              写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。</p>
<p>​          2.指令语法：</p>
<p>​              功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。</p>
<p>​              举例：v-bind:href=&quot;xxx&quot; 或  简写为 :href=&quot;xxx&quot;，xxx同样要写js表达式，</p>
<p>​                   且可以直接读取到data中的所有属性。</p>
<p>Vue中有2种数据绑定的方式：</p>
<p>​          1.单向绑定(v-bind)：数据只能从data流向页面。</p>
<p>​          2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p>
<p>​            备注：</p>
<p>​                1.双向绑定一般都应用在表单类元素上（如：input、select等）</p>
<p>​                2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p>
<pre><code class="language-js">&lt;!-- 简写 --&gt;
			单向数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt;
			双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;
</code></pre>
<p>data与el的2种写法</p>
<p>​          1.el有2种写法</p>
<p>​                  (1).new Vue时候配置el属性。</p>
<p>​                  (2).先创建Vue实例，随后再通过vm.$mount('#root')指定el的值。</p>
<p>​          2.data有2种写法</p>
<p>​                  (1).对象式</p>
<p>​                  (2).函数式</p>
<p>​                  如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</p>
<p>​          3.一个重要的原则：</p>
<p>​                  由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</p>
<h2 id="mvvm模型">MVVM模型</h2>
<p>MVVM模型</p>
<ol>
<li>​            \1. M：模型(Model) ：data中的数据</li>
<li>​            \2. V：视图(View) ：模板代码</li>
<li>​            \3. VM：视图模型(ViewModel)：Vue实例</li>
</ol>
<p>​      观察发现：</p>
<p>​            1.data中所有的属性，最后都出现在了vm身上。</p>
<p>​            2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p>
<h2 id="数据代理">数据代理</h2>
<p>1.Vue中的数据代理：</p>
<p>​              通过vm对象来代理data对象中属性的操作（读/写）</p>
<p>2.Vue中数据代理的好处：</p>
<p>​              更加方便的操作data中的数据</p>
<p>3.基本原理：</p>
<p>​              通过Object.defineProperty()把data对象中所有属性添加到vm上。</p>
<p>​              为每一个添加到vm上的属性，都指定一个getter/setter。</p>
<p>​              在getter/setter内部去操作（读/写）data中对应的属性。</p>
<h2 id="事件处理">事件处理</h2>
<h3 id="基本使用">基本使用</h3>
<p>​              1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</p>
<p>​              2.事件的回调需要配置在methods对象中，最终会在vm上；</p>
<p>​              3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；</p>
<p>​              4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</p>
<p>​              5.@click=&quot;demo&quot; 和 @click=&quot;demo($event)&quot; 效果一致，但后者可以传参；</p>
<h3 id="事件修饰符">事件修饰符：</h3>
<p>​            1.prevent：阻止默认事件（常用）；</p>
<p>​            2.stop：阻止事件冒泡（常用）；</p>
<p>​            3.once：事件只触发一次（常用）；</p>
<p>​            4.capture：使用事件的捕获模式；</p>
<p>​            5.self：只有event.target是当前操作的元素时才触发事件；</p>
<p>​            6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p>
<h3 id="键盘事件">键盘事件</h3>
<p>1.Vue中常用的按键别名：</p>
<p>​              回车 =&gt; enter</p>
<p>​              删除 =&gt; delete (捕获“删除”和“退格”键)</p>
<p>​              退出 =&gt; esc</p>
<p>​              空格 =&gt; space</p>
<p>​              换行 =&gt; tab (特殊，必须配合keydown去使用)</p>
<p>​              上 =&gt; up</p>
<p>​              下 =&gt; down</p>
<p>​              左 =&gt; left</p>
<p>​              右 =&gt; right</p>
<p>​        2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p>
<p>​        3.系统修饰键（用法特殊）：ctrl、alt、shift、meta</p>
<p>​              (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p>
<p>​              (2).配合keydown使用：正常触发事件。</p>
<p>​        4.也可以使用keyCode去指定具体的按键（不推荐）</p>
<p>​        5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</p>
<h2 id="计算属性">计算属性</h2>
<h3 id="计算属性-2">计算属性：</h3>
<p>​          1.定义：要用的属性不存在，要通过已有属性计算得来。</p>
<p>​          2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</p>
<p>​          3.get函数什么时候执行？</p>
<p>​                (1).初次读取时会执行一次。</p>
<p>​                (2).当依赖的数据发生改变时会被再次调用。</p>
<p>​          4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p>
<p>​          5.备注：</p>
<p>​              1.计算属性最终会出现在vm上，直接读取使用即可。</p>
<p>​              2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p>
<pre><code class="language-js">computed:{
    fullName:{
        //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值
        //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。
        get(){
            console.log('get被调用了')
            // console.log(this) //此处的this是vm
            return this.firstName + '-' + this.lastName
        },
        //set什么时候调用? 当fullName被修改时。
        set(value){
            console.log('set',value)
            const arr = value.split('-')
            this.firstName = arr[0]
            this.lastName = arr[1]
         }
    }
}
</code></pre>
<p>只有get时，可以简写</p>
<pre><code class="language-js">//简写
fullName(){
	console.log('get被调用了')
	return this.firstName + '-' + this.lastName
}
</code></pre>
<h2 id="监视属性">监视属性</h2>
<h3 id="监视属性watch">监视属性watch：</h3>
<p>​          1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p>
<p>​          2.监视的属性必须存在，才能进行监视！！</p>
<p>​          3.监视的两种写法：</p>
<p>​              (1).new Vue时传入watch配置</p>
<p>​              (2).通过vm.$watch监视</p>
<pre><code class="language-js">watch:{
    isHot:{
        immediate:true, //初始化时让handler调用一下
        //handler什么时候调用？当isHot发生改变时。
        handler(newValue,oldValue){
        console.log('isHot被修改了',newValue,oldValue)
    }
}
</code></pre>
<pre><code class="language-js">vm.$watch('isHot',{
    immediate:true, //初始化时让handler调用一下
    //handler什么时候调用？当isHot发生改变时。
    handler(newValue,oldValue){
    console.log('isHot被修改了',newValue,oldValue)
    }
})
</code></pre>
<h3 id="深度监视">深度监视：</h3>
<p>​            (1).Vue中的watch默认不监测对象内部值的改变（一层）。</p>
<p>​            (2).配置deep:true可以监测对象内部值改变（多层）。</p>
<h3 id="computed对比watch">computed对比watch</h3>
<p>computed和watch之间的区别：</p>
<p>​            1.computed能完成的功能，watch都可以完成。</p>
<p>​            2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p>
<p><strong>两个重要的小原则</strong>：</p>
<p>​              1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</p>
<p>​              2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</p>
<h2 id="绑定样式">绑定样式</h2>
<p>\1. class样式</p>
<p>​                写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。</p>
<p>​                    字符串写法适用于：类名不确定，要动态获取。</p>
<p>​                    对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p>
<p>​                    数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p>
<p>​          \2. style样式</p>
<p>​                :style=&quot;{fontSize: xxx}&quot;其中xxx是动态值。</p>
<p>​                :style=&quot;[a,b]&quot;其中a、b是样式对象。</p>
<h2 id="条件渲染">条件渲染</h2>
<p>条件渲染：</p>
<p>​              1.v-if</p>
<p>​                    写法：</p>
<p>​                        (1).v-if=&quot;表达式&quot;</p>
<p>​                        (2).v-else-if=&quot;表达式&quot;</p>
<p>​                        (3).v-else=&quot;表达式&quot;</p>
<p>​                    适用于：切换频率较低的场景。</p>
<p>​                    特点：不展示的DOM元素直接被移除。</p>
<p>​                    注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p>
<p>​              2.v-show</p>
<p>​                    写法：v-show=&quot;表达式&quot;</p>
<p>​                    适用于：切换频率较高的场景。</p>
<p>​                    特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p>
<p>​</p>
<p>​              3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p>
<p>​				template只能和v-if配合使用</p>
<h2 id="列表渲染">列表渲染</h2>
<h3 id="v-for指令">v-for指令:</h3>
<p>​            1.用于展示列表数据</p>
<p>​            2.语法：v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;</p>
<p>​            3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p>
<p>react、vue中的key有什么作用？（key的内部原理）</p>
<h3 id="拟dom中key的作用">拟DOM中key的作用：</h3>
<p>​                    key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,</p>
<p>​                    随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
<p>​           对比规则：</p>
<p>​                  (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：</p>
<p>​                        ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</p>
<p>​                        ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p>
<p>​                  (2).旧虚拟DOM中未找到与新虚拟DOM相同的key</p>
<p>​                        创建新的真实DOM，随后渲染到到页面。</p>
<h3 id="vueset">Vue.set()</h3>
<p>给data中的响应式对象添加新属性，该对象不能是vue实例或data根数据对象</p>
<pre><code class="language-js">const vm = new Vue({
			el:'#root',
			data:{
				student:{
					name:'tom',
					age:{
						rAge:40,
						sAge:29,
					}
				}
			},
			methods: {
				addSex(){
					// Vue.set(this.student,'sex','男')
					this.$set(this.student,'sex','男')
				}
			}
		})
</code></pre>
<h2 id="数据检测原理">数据检测原理</h2>
<p>\1. vue会监视data中所有层次的数据。</p>
<p>​        \2. 如何监测对象中的数据？</p>
<p>利用数据劫持，<em>Object</em>.defineProperties()给对象每个属性添加get、set</p>
<p>​                通过setter实现监视，且要在new Vue时就传入要监测的数据。</p>
<p>​                  (1).对象中后追加的属性，Vue默认不做响应式处理</p>
<p>​                  (2).如需给后添加的属性做响应式，请使用如下API：</p>
<p>​                          Vue.set(target，propertyName/index，value) 或</p>
<p>​                          vm.$set(target，propertyName/index，value)</p>
<p>​        \3. 如何监测数组中的数据？</p>
<p>​                  通过包裹数组更新元素的方法实现，本质就是做了两件事：</p>
<p>​                    (1).调用原生对应的方法对数组进行更新。</p>
<p>​                    (2).重新解析模板，进而更新页面。</p>
<p>​        4.在Vue修改数组中的某个元素一定要用如下方法：</p>
<p>​              1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p>
<p>​              2.Vue.set() 或 vm.$set()</p>
<p>​			3.其他不改变原数组的方法时要重新覆盖原数组</p>
<h2 id="收集表单数据">收集表单数据</h2>
<p>若：<input type="text"/>，则v-model收集的是value值，用户输入的就是value值。</p>
<p>​          若：<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值。</p>
<p>​          若：<input type="checkbox"/></p>
<p>​              1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p>
<p>​              2.配置input的value属性:</p>
<p>​                  (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p>
<p>​                  (2)v-model的初始值是数组，那么收集的的就是value组成的数组</p>
<p>​          备注：v-model的三个修饰符：</p>
<p>​                  lazy：失去焦点再收集数据</p>
<p>​                  number：输入字符串转为有效的数字</p>
<p>​                  trim：输入首尾空格过滤</p>
<h2 id="过滤器">过滤器</h2>
<p>定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p>
<p>​        语法：</p>
<p>​            1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}</p>
<p>​            2.使用过滤器：{{ xxx | 过滤器名}}  或  v-bind:属性 = &quot;xxx | 过滤器名&quot;</p>
<p>​        备注：</p>
<p>​            1.过滤器也可以接收额外参数、多个过滤器也可以串联</p>
<p>​            2.并没有改变原本的数据, 是产生新的对应的数据</p>
<pre><code class="language-js">&lt;div id=&quot;root&quot;&gt;
			&lt;h2&gt;显示格式化后的时间&lt;/h2&gt;
			&lt;!-- 计算属性实现 --&gt;
			&lt;h3&gt;现在是：{{fmtTime}}&lt;/h3&gt;
			&lt;!-- methods实现 --&gt;
			&lt;h3&gt;现在是：{{getFmtTime()}}&lt;/h3&gt;
			&lt;!-- 过滤器实现 --&gt;
			&lt;h3&gt;现在是：{{time | timeFormater}}&lt;/h3&gt;
			&lt;!-- 过滤器实现（传参） --&gt;
			&lt;h3&gt;现在是：{{time | timeFormater('YYYY_MM_DD') | mySlice}}&lt;/h3&gt;
			&lt;h3 :x=&quot;msg | mySlice&quot;&gt;尚硅谷&lt;/h3&gt;
		&lt;/div&gt;
	&lt;/body&gt;

		//全局过滤器
		Vue.filter('mySlice',function(value){
			return value.slice(0,4)
		})
		
		new Vue({
			el:'#root',
			data:{
				time:1621561377603, //时间戳
				msg:'你好，尚硅谷'
			},
			computed: {
				fmtTime(){
					return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss')
				}
			},
			methods: {
				getFmtTime(){
					return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss')
				}
			},
			//局部过滤器
			filters:{
				timeFormater(value,str='YYYY年MM月DD日 HH:mm:ss'){
					return dayjs(value).format(str)
				}
			}
		})
</code></pre>
<h2 id="vue指令">Vue指令</h2>
<h3 id="v-bind">v-bind</h3>
<p>单向绑定解析表达式, 可简写为 :xxx</p>
<h3 id="v-model">v-model</h3>
<p>双向数据绑定</p>
<h3 id="v-for">v-for</h3>
<p>遍历数组/对象/字符串</p>
<h3 id="v-on">v-on</h3>
<p>绑定事件监听, 可简写为@</p>
<h3 id="v-if">v-if</h3>
<p>条件渲染（动态控制节点是否存存在）</p>
<h3 id="v-else">v-else</h3>
<p>条件渲染（动态控制节点是否存存在）</p>
<h3 id="v-show">v-show</h3>
<p>条件渲染 (动态控制节点是否展示)</p>
<h3 id="v-text">v-text</h3>
<p>1.作用：向其所在的节点中渲染文本内容。</p>
<p>2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。</p>
<h3 id="v-html">v-html</h3>
<p>1.作用：向指定节点中渲染包含html结构的内容。</p>
<p>2.与插值语法的区别：</p>
<p>​                  (1).v-html会替换掉节点中所有的内容，{{xx}}则不会。</p>
<p>​                  (2).v-html可以识别html结构。</p>
<p>3.严重注意：v-html有安全性问题！！！！</p>
<p>​                  (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p>
<p>​                  (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p>
<h3 id="v-clock">v-clock</h3>
<p>1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</p>
<p>2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。</p>
<pre><code class="language-js">&lt;style&gt;
    [v-cloak]{
    	display:none;
    }
&lt;/style&gt;

&lt;div id=&quot;root&quot;&gt;
    &lt;h2 v-cloak&gt;{{name}}&lt;/h2&gt;
&lt;/div&gt;
</code></pre>
<h3 id="v-once">v-once</h3>
<p>1.v-once所在节点在初次动态渲染后，就视为静态内容了。</p>
<p>2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p>
<pre><code class="language-js">&lt;h2 v-once&gt;初始化的n值是:{{n}}&lt;/h2&gt;
</code></pre>
<h3 id="v-pre">v-pre</h3>
<p>1.跳过其所在节点的编译过程。</p>
<p>2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p>
<h3 id="自定义指令">自定义指令</h3>
<p>一、定义语法：</p>
<p>​                  (1).局部指令：</p>
<p>​                        new Vue({                              new Vue({</p>
<p>​                          directives:{指令名:配置对象}  或      directives{指令名:回调函数}</p>
<p>​                        })                                    })</p>
<p>​                  (2).全局指令：</p>
<p>​                          Vue.directive(指令名,配置对象) 或  Vue.directive(指令名,回调函数)</p>
<p>​            二、配置对象中常用的3个回调：</p>
<p>​                  (1).bind：指令与元素成功绑定时调用。</p>
<p>​                  (2).inserted：指令所在元素被插入页面时调用。</p>
<p>​                  (3).update：指令所在模板结构被重新解析时调用。</p>
<p>​            三、备注：</p>
<p>​                  1.指令定义时不加v-，但使用时要加v-；</p>
<p>​                  2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。</p>
<p>​					3.this指向window</p>
<h2 id="生命周期">生命周期</h2>
<p>生命周期函数中的this指向是vm 或 组件实例对象</p>
<p>生命周期回调函数、生命周期函数、生命周期钩子</p>
<p>常用的生命周期钩子：</p>
<p>​            1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</p>
<p>​            2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p>
<p>​        关于销毁Vue实例</p>
<p>​            1.销毁后借助Vue开发者工具看不到任何信息。</p>
<p>​            2.销毁后自定义事件会失效，但原生DOM事件依然有效。</p>
<p>​            3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p>
<h2 id="组件">组件</h2>
<figure data-type="image" tabindex="1"><a href="https://postimg.cc/yk9PsjxD"><img src="https://i.postimg.cc/L6Q0k0M3/image-20220812085646674.png" alt="image-20220812085646674.png" loading="lazy"></a></figure>
<h2 id="ref属性">ref属性</h2>
<ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：
<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2 id="props配置项"><strong>props配置项</strong></h2>
<ol>
<li>
<p>功能：让组件接收外部传过来的数据</p>
</li>
<li>
<p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li>
<p>接收数据：</p>
<ol>
<li>
<p>第一种方式（只接收）：<code>props:['name'] </code></p>
</li>
<li>
<p>第二种方式（限制类型）：<code>props:{name:String}</code></p>
</li>
<li>
<p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
<pre><code class="language-js">props:{
 name:{
 type:String, //类型
 required:true, //必要性
 default:'老王' //默认值
 }
}
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
<p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</blockquote>
</li>
</ol>
<h2 id="mixin混入">mixin(混入)</h2>
<ol>
<li>
<p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li>
<p>使用方式：</p>
<p>第一步定义混合：</p>
<pre><code>{
    data(){....},
    methods:{....}
    ....
}
</code></pre>
<p>第二步使用混入：</p>
<p>全局混入：<code>Vue.mixin(xxx)</code><br>
局部混入：<code>mixins:['xxx']  </code></p>
</li>
</ol>
<h2 id="插件">插件</h2>
<ol>
<li>
<p>功能：用于增强Vue</p>
</li>
<li>
<p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li>
<p>定义插件：</p>
<pre><code class="language-js">对象.install = function (Vue, options) {
    // 1. 添加全局过滤器
    Vue.filter(....)

    // 2. 添加全局指令
    Vue.directive(....)

    // 3. 配置全局混入(合)
    Vue.mixin(....)

    // 4. 添加实例方法
    Vue.prototype.$myMethod = function () {...}
    Vue.prototype.$myProperty = xxxx
}
</code></pre>
</li>
<li>
<p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2 id="scoped样式"><strong>scoped样式</strong></h2>
<p>\1. 作用：让样式在局部生效，防止冲突。</p>
<p>\2. 写法：<code>&lt;style scoped&gt;</code></p>
<h2 id="自定义事件">自定义事件</h2>
<p>\1. 一种组件间通信的方式，适用于：<strong>子组件 ===&gt; 父组件</strong></p>
<p>\2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（&lt;span <em>style</em>=&quot;color:red&quot;&gt;事件的回调在A中</span>）。</p>
<p>\3. 绑定自定义事件：</p>
<pre><code>1. 第一种方式，在父组件中：```&lt;Demo @atguigu=&quot;test&quot;/&gt;```  或 ```&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;```

    2. 第二种方式，在父组件中：

    ```js
    &lt;Demo ref=&quot;demo&quot;/&gt;
    ......
    mounted(){
       this.$refs.xxx.$on('atguigu',this.test)
    }
    ```

    3. 若想让自定义事件只能触发一次，可以使用```once```修饰符，或```$once```方法。
</code></pre>
<ol start="4">
<li>
<p>触发自定义事件：<code>this.$emit('atguigu',数据)</code></p>
</li>
<li>
<p>解绑自定义事件<code>this.$off('atguigu')</code></p>
</li>
<li>
<p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li>
<p>注意：通过<code>this.$refs.xxx.$on('atguigu',回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线globaleventbus">全局事件总线（GlobalEventBus）</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>安装全局事件总线：</p>
<pre><code class="language-js">new Vue({
   ......
   beforeCreate() {
      Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
   },
    ......
}) 
</code></pre>
</li>
<li>
<p>使用事件总线：</p>
<ol>
<li>
<p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.$bus.$on('xxxx',this.demo)
}
</code></pre>
</li>
<li>
<p>提供数据：<code>this.$bus.$emit('xxxx',数据)</code></p>
</li>
</ol>
</li>
<li>
<p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布pubsub">消息订阅与发布（pubsub）</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>使用步骤：</p>
<ol>
<li>
<p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li>
<p>引入: <code>import pubsub from 'pubsub-js'</code></p>
</li>
<li>
<p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息
}
</code></pre>
</li>
<li>
<p>提供数据：<code>pubsub.publish('xxx',数据)</code></p>
</li>
<li>
<p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(this.pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="nexttick">nextTick</h2>
<ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<h2 id="vue封装的过度与动画">Vue封装的过度与动画</h2>
<ol>
<li>
<p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li>
<p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105"/></p>
</li>
<li>
<p>写法：</p>
<ol>
<li>
<p>准备好样式：</p>
<ul>
<li>元素进入的样式：
<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：
<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li>
<p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<pre><code class="language-vue">&lt;transition name=&quot;hello&quot;&gt;
   &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
&lt;/transition&gt;
</code></pre>
</li>
<li>
<p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="vue脚手架配置代理">vue脚手架配置代理</h2>
<h3 id="方法一">方法一</h3>
<p>在vue.config.js中添加如下配置：</p>
<pre><code class="language-js">devServer:{
  proxy:&quot;http://localhost:5000&quot;
}
</code></pre>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二">方法二</h3>
<p>编写vue.config.js配置具体代理规则：</p>
<pre><code class="language-js">module.exports = {
   devServer: {
      proxy: {
      '/api1': {// 匹配所有以 '/api1'开头的请求路径
        target: 'http://localhost:5000',// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {'^/api1': ''}
      },
      '/api2': {// 匹配所有以 '/api2'开头的请求路径
        target: 'http://localhost:5001',// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {'^/api2': ''}
      }
    }
  }
}
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
</code></pre>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="插槽">插槽</h2>
<ol>
<li>
<p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p>
</li>
<li>
<p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li>
<p>使用方式：</p>
<ol>
<li>
<p>默认插槽：</p>
<pre><code class="language-vue">父组件中：
        &lt;Category&gt;
           &lt;div&gt;html结构1&lt;/div&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li>
<p>具名插槽：</p>
<pre><code class="language-vue">父组件中：
        &lt;Category&gt;
            &lt;template slot=&quot;center&quot;&gt;
              &lt;div&gt;html结构1&lt;/div&gt;
            &lt;/template&gt;

            &lt;template v-slot:footer&gt;
               &lt;div&gt;html结构2&lt;/div&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;
               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li>
<p>作用域插槽：</p>
<ol>
<li>
<p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-vue">父组件中：
      &lt;Category&gt;
         &lt;template scope=&quot;scopeData&quot;&gt;
            &lt;!-- 生成的是ul列表 --&gt;
            &lt;ul&gt;
               &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/template&gt;
      &lt;/Category&gt;

      &lt;Category&gt;
         &lt;template slot-scope=&quot;scopeData&quot;&gt;
            &lt;!-- 生成的是h4标题 --&gt;
            &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/h4&gt;
         &lt;/template&gt;
      &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
      
        &lt;script&gt;
            export default {
                name:'Category',
                props:['title'],
                //数据在子组件自身
                data() {
                    return {
                        games:['红色警戒','穿越火线','劲舞团','超级玛丽']
                    }
                },
            }
        &lt;/script&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<pre><code>
</code></pre>
</li>
</ol>
<h2 id="vuex">Vuex</h2>
<h3 id="1概念">1.概念</h3>
<p>​     在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2何时使用">2.何时使用？</h3>
<p>​     多个组件需要共享数据时</p>
<h3 id="3搭建vuex环境">3.搭建vuex环境</h3>
<ol>
<li>
<p>创建文件：<code>src/store/index.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from 'vue'
//引入Vuex
import Vuex from 'vuex'
//应用Vuex插件
Vue.use(Vuex)

//准备actions对象——响应组件中用户的动作
const actions = {}
//准备mutations对象——修改state中的数据
const mutations = {}
//准备state对象——保存具体的数据
const state = {}

//创建并暴露store
export default new Vuex.Store({
   actions,
   mutations,
   state
})
</code></pre>
</li>
<li>
<p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<pre><code class="language-js">......
//引入store
import store from './store'
......

//创建vm
new Vue({
   el:'#app',
   render: h =&gt; h(App),
   store
})
</code></pre>
</li>
</ol>
<h3 id="4基本使用">4.基本使用</h3>
<ol>
<li>
<p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from 'vue'
//引入Vuex
import Vuex from 'vuex'
//引用Vuex
Vue.use(Vuex)

const actions = {
    //响应组件中加的动作
   jia(context,value){
      // console.log('actions中的jia被调用了',miniStore,value)
      context.commit('JIA',value)
   },
}

const mutations = {
    //执行加
   JIA(state,value){
      // console.log('mutations中的JIA被调用了',state,value)
      state.sum += value
   }
}

//初始化数据
const state = {
   sum:0
}

//创建并暴露store
export default new Vuex.Store({
   actions,
   mutations,
   state,
})
</code></pre>
</li>
<li>
<p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li>
<p>组件中修改vuex中的数据：<code>$store.dispatch('action中的方法名',数据)</code> 或 <code>$store.commit('mutations中的方法名',数据)</code></p>
<blockquote>
<p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5getters的使用">5.getters的使用</h3>
<ol>
<li>
<p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li>
<p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<pre><code class="language-js">......

const getters = {
   bigSum(state){
      return state.sum * 10
   }
}

//创建并暴露store
export default new Vuex.Store({
   ......
   getters
})
</code></pre>
</li>
<li>
<p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6四个map方法的使用">6.四个map方法的使用</h3>
<ol>
<li>
<p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapState生成计算属性：sum、school、subject（对象写法）
     ...mapState({sum:'sum',school:'school',subject:'subject'}),
         
    //借助mapState生成计算属性：sum、school、subject（数组写法）
    ...mapState(['sum','school','subject']),
},
</code></pre>
</li>
<li>
<p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapGetters生成计算属性：bigSum（对象写法）
    ...mapGetters({bigSum:'bigSum'}),

    //借助mapGetters生成计算属性：bigSum（数组写法）
    ...mapGetters(['bigSum'])
},
</code></pre>
</li>
<li>
<p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：incrementOdd、incrementWait（对象形式）
    ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})

    //靠mapActions生成：incrementOdd、incrementWait（数组形式）
    ...mapActions(['jiaOdd','jiaWait'])
}
</code></pre>
</li>
<li>
<p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：increment、decrement（对象形式）
    ...mapMutations({increment:'JIA',decrement:'JIAN'}),
    
    //靠mapMutations生成：JIA、JIAN（对象形式）
    ...mapMutations(['JIA','JIAN']),
}
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7模块化命名空间">7.模块化+命名空间</h3>
<ol>
<li>
<p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li>
<p>修改<code>store.js</code></p>
<pre><code class="language-javascript">const countAbout = {
  namespaced:true,//开启命名空间
  state:{x:1},
  mutations: { ... },
  actions: { ... },
  getters: {
    bigSum(state){
       return state.sum * 10
    }
  }
}

const personAbout = {
  namespaced:true,//开启命名空间
  state:{ ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    countAbout,
    personAbout
  }
})
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中读取state数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState('countAbout',['sum','school','subject']),
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中读取getters数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.getters['personAbout/firstPersonName']
//方式二：借助mapGetters读取：
...mapGetters('countAbout',['bigSum'])
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中调用dispatch</p>
<pre><code class="language-js">//方式一：自己直接dispatch
this.$store.dispatch('personAbout/addPersonWang',person)
//方式二：借助mapActions：
...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中调用commit</p>
<pre><code class="language-js">//方式一：自己直接commit
this.$store.commit('personAbout/ADD_PERSON',person)
//方式二：借助mapMutations：
...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),
</code></pre>
</li>
</ol>
<h2 id="路由">路由</h2>
<ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="1基本使用">1.基本使用</h3>
<ol>
<li>
<p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li>
<p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li>
<p>编写router配置项:</p>
<pre><code class="language-js">//引入VueRouter
import VueRouter from 'vue-router'
//引入Luyou 组件
import About from '../components/About'
import Home from '../components/Home'

//创建router实例对象，去管理一组一组的路由规则
const router = new VueRouter({
   routes:[
      {
         path:'/about',
         component:About
      },
      {
         path:'/home',
         component:Home
      }
   ]
})

//暴露router
export default router
</code></pre>
</li>
<li>
<p>实现切换（active-class可配置高亮样式）</p>
<pre><code class="language-vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
</code></pre>
</li>
<li>
<p>指定展示位置</p>
<pre><code class="language-vue">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
</li>
</ol>
<h3 id="2几个注意点">2.几个注意点</h3>
<ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3多级路由多级路由">3.多级路由（多级路由）</h3>
<ol>
<li>
<p>配置路由规则，使用children配置项：</p>
<pre><code class="language-js">routes:[
   {
      path:'/about',
      component:About,
   },
   {
      path:'/home',
      component:Home,
      children:[ //通过children配置子级路由
         {
            path:'news', //此处一定不要写：/news
            component:News
         },
         {
            path:'message',//此处一定不要写：/message
            component:Message
         }
      ]
   }
]
</code></pre>
</li>
<li>
<p>跳转（要写完整路径）：</p>
<pre><code class="language-vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
</li>
</ol>
<h3 id="4路由的query参数">4.路由的query参数</h3>
<ol>
<li>
<p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;
            
&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;
&lt;router-link 
   :to=&quot;{
      path:'/home/message/detail',
      query:{
         id:666,
            title:'你好'
      }
   }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
<li>
<p>接收参数：</p>
<pre><code class="language-js">$route.query.id
$route.query.title
</code></pre>
</li>
</ol>
<h3 id="5命名路由">5.命名路由</h3>
<ol>
<li>
<p>作用：可以简化路由的跳转。</p>
</li>
<li>
<p>如何使用</p>
<ol>
<li>
<p>给路由命名：</p>
<pre><code class="language-js">{
   path:'/demo',
   component:Demo,
   children:[
      {
         path:'test',
         component:Test,
         children:[
            {
                      name:'hello' //给路由命名
               path:'welcome',
               component:Hello,
            }
         ]
      }
   ]
}
</code></pre>
</li>
<li>
<p>简化跳转：</p>
<pre><code class="language-vue">&lt;!--简化前，需要写完整的路径 --&gt;
&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化后，直接通过名字跳转 --&gt;
&lt;router-link :to=&quot;{name:'hello'}&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化写法配合传递参数 --&gt;
&lt;router-link 
   :to=&quot;{
      name:'hello',
      query:{
         id:666,
            title:'你好'
      }
   }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="6路由的params参数">6.路由的params参数</h3>
<ol>
<li>
<p>配置路由，声明接收params参数</p>
<pre><code class="language-js">{
   path:'/home',
   component:Home,
   children:[
      {
         path:'news',
         component:News
      },
      {
         component:Message,
         children:[
            {
               name:'xiangqing',
               path:'detail/:id/:title', //使用占位符声明接收params参数
               component:Detail
            }
         ]
      }
   ]
}
</code></pre>
</li>
<li>
<p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;
            
&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;
&lt;router-link 
   :to=&quot;{
      name:'xiangqing',
      params:{
         id:666,
            title:'你好'
      }
   }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li>
<p>接收参数：</p>
<pre><code class="language-js">$route.params.id
$route.params.title
</code></pre>
</li>
</ol>
<h3 id="7路由的props配置">7.路由的props配置</h3>
<p>作用：让路由组件更方便的收到参数</p>
<pre><code class="language-js">{
   name:'xiangqing',
   path:'detail/:id',
   component:Detail,

   //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
   // props:{a:900}

   //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
   // props:true
   
   //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
   props(route){
      return {
         id:route.query.id,
         title:route.query.title
      }
   }
}
</code></pre>
<h3 id="8router-link的replace属性">8.<code>&lt;router-link&gt;</code>的replace属性</h3>
<ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9编程式路由导航">9.编程式路由导航</h3>
<ol>
<li>
<p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-js">//$router的两个API
this.$router.push({
   name:'xiangqing',
      params:{
         id:xxx,
         title:xxx
      }
})

this.$router.replace({
   name:'xiangqing',
      params:{
         id:xxx,
         title:xxx
      }
})
this.$router.forward() //前进
this.$router.back() //后退
this.$router.go() //可前进也可后退
</code></pre>
</li>
</ol>
<h3 id="10缓存路由组件">10.缓存路由组件</h3>
<ol>
<li>
<p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-vue">&lt;keep-alive include=&quot;News&quot;&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
</li>
</ol>
<h3 id="11两个新的生命周期钩子">11.两个新的生命周期钩子</h3>
<ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：
<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12路由守卫">12.路由守卫</h3>
<ol>
<li>
<p>作用：对路由进行权限控制</p>
</li>
<li>
<p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li>
<p>全局守卫:</p>
<pre><code class="language-js">//全局前置守卫：初始化时执行、每次路由切换前执行
router.beforeEach((to,from,next)=&gt;{
   console.log('beforeEach',to,from)
   if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
      if(localStorage.getItem('school') === 'atguigu'){ //权限控制的具体规则
         next() //放行
      }else{
         alert('暂无权限查看')
         // next({name:'guanyu'})
      }
   }else{
      next() //放行
   }
})

//全局后置守卫：初始化时执行、每次路由切换后执行
router.afterEach((to,from)=&gt;{
   console.log('afterEach',to,from)
   if(to.meta.title){ 
      document.title = to.meta.title //修改网页的title
   }else{
      document.title = 'vue_test'
   }
})
</code></pre>
</li>
<li>
<p>独享守卫:</p>
<pre><code class="language-js">beforeEnter(to,from,next){
   console.log('beforeEnter',to,from)
   if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
      if(localStorage.getItem('school') === 'atguigu'){
         next()
      }else{
         alert('暂无权限查看')
         // next({name:'guanyu'})
      }
   }else{
      next()
   }
}
</code></pre>
</li>
<li>
<p>组件内守卫：</p>
<pre><code class="language-js">//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) {
},
//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) {
}
</code></pre>
</li>
</ol>
<h3 id="13路由器的两种工作模式">13.路由器的两种工作模式</h3>
<ol>
<li>
<p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</p>
</li>
<li>
<p>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</p>
</li>
<li>
<p>hash模式：</p>
<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>
<p>history模式：</p>
<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue3]]></title>
        <id>https://kingshuxin.github.io/post/vue3/</id>
        <link href="https://kingshuxin.github.io/post/vue3/">
        </link>
        <updated>2022-08-30T15:20:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1拉开序幕的setup">1.拉开序幕的setup</h2>
<ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：
<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：
<ol>
<li>尽量不要与Vue2.x配置混用
<ul>
<li>Vue2.x配置（data、methos、computed...）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed...）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h2 id="2ref函数">2.ref函数</h2>
<ul>
<li>作用: 定义一个响应式的数据</li>
<li>语法: <code>const xxx = ref(initValue)</code>
<ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{{xxx}}&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：
<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h2 id="3reactive函数">3.reactive函数</h2>
<ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h2 id="4vue30中的响应式原理">4.Vue3.0中的响应式原理</h2>
<h3 id="vue2x的响应式">vue2.x的响应式</h3>
<ul>
<li>
<p>实现原理：</p>
<ul>
<li>
<p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li>
<p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<pre><code class="language-js">Object.defineProperty(data, 'count', {
    get () {}, 
    set () {}
})
</code></pre>
</li>
</ul>
</li>
<li>
<p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="vue30的响应式">Vue3.0的响应式</h3>
<ul>
<li>
<p>实现原理:</p>
<ul>
<li>
<p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p>
</li>
<li>
<p>通过Reflect（反射）:  对源对象的属性进行操作。</p>
</li>
<li>
<p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li>
<p>Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</p>
</li>
<li>
<p>Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</p>
<pre><code class="language-js">new Proxy(data, {
	// 拦截读取属性值
    get (target, prop) {
    	return Reflect.get(target, prop)
    },
    // 拦截设置属性值或添加新属性
    set (target, prop, value) {
    	return Reflect.set(target, prop, value)
    },
    // 拦截删除属性
    deleteProperty (target, prop) {
    	return Reflect.deleteProperty(target, prop)
    }
})

proxy.name = 'tom'   
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5reactive对比ref">5.reactive对比ref</h2>
<ul>
<li>从定义数据角度对比：
<ul>
<li>ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li>reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li>备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：
<ul>
<li>ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：
<ul>
<li>ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li>reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h2 id="6setup的两个注意点">6.setup的两个注意点</h2>
<ul>
<li>
<p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li>
<p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象
<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7计算属性与监视">7.计算属性与监视</h2>
<h3 id="1computed函数">1.computed函数</h3>
<ul>
<li>
<p>与Vue2.x中computed配置功能一致</p>
</li>
<li>
<p>写法</p>
<pre><code class="language-js">import {computed} from 'vue'

setup(){
    ...
	//计算属性——简写
    let fullName = computed(()=&gt;{
        return person.firstName + '-' + person.lastName
    })
    //计算属性——完整
    let fullName = computed({
        get(){
            return person.firstName + '-' + person.lastName
        },
        set(value){
            const nameArr = value.split('-')
            person.firstName = nameArr[0]
            person.lastName = nameArr[1]
        }
    })
}
</code></pre>
</li>
</ul>
<h3 id="2watch函数">2.watch函数</h3>
<ul>
<li>
<p>与Vue2.x中watch配置功能一致</p>
</li>
<li>
<p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<pre><code class="language-js">//情况一：监视ref定义的响应式数据
watch(sum,(newValue,oldValue)=&gt;{
	console.log('sum变化了',newValue,oldValue)
},{immediate:true})

//情况二：监视多个ref定义的响应式数据
watch([sum,msg],(newValue,oldValue)=&gt;{
	console.log('sum或msg变化了',newValue,oldValue)
}) 

/* 情况三：监视reactive定义的响应式数据
			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！
			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 
*/
watch(person,(newValue,oldValue)=&gt;{
	console.log('person变化了',newValue,oldValue)
},{immediate:true,deep:false}) //此处的deep配置不再奏效

//情况四：监视reactive定义的响应式数据中的某个属性
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true}) 

//情况五：监视reactive定义的响应式数据中的某些属性
watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{
	console.log('person的job变化了',newValue,oldValue)
},{immediate:true,deep:true})

//特殊情况
watch(()=&gt;person.job,(newValue,oldValue)=&gt;{
    console.log('person的job变化了',newValue,oldValue)
},{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效
</code></pre>
</li>
</ul>
<h3 id="3watcheffect函数">3.watchEffect函数</h3>
<ul>
<li>
<p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li>
<p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li>
<p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<pre><code class="language-js">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。
watchEffect(()=&gt;{
    const x1 = sum.value
    const x2 = person.age
    console.log('watchEffect配置的回调执行了')
})
</code></pre>
</li>
</ul>
<h2 id="8生命周期">8.生命周期</h2>
<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：
<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：
<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>=======&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>=======&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> =======&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h2 id="9自定义hook函数">9.自定义hook函数</h2>
<ul>
<li>
<p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li>
<p>类似于vue2.x中的mixin。</p>
</li>
<li>
<p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h2 id="10toref">10.toRef</h2>
<ul>
<li>
<p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li>
<p>语法：<code>const name = toRef(person,'name')</code></p>
</li>
<li>
<p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li>
<p>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
</li>
</ul>
<h1 id="三-其它-composition-api">三、其它 Composition API</h1>
<h2 id="1shallowreactive-与-shallowref">1.shallowReactive 与 shallowRef</h2>
<ul>
<li>
<p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li>
<p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li>
<p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="2readonly-与-shallowreadonly">2.readonly 与 shallowReadonly</h2>
<ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="3toraw-与-markraw">3.toRaw 与 markRaw</h2>
<ul>
<li>toRaw：
<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：
<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:
<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4customref">4.customRef</h2>
<ul>
<li>
<p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li>
<p>实现防抖效果：</p>
<pre><code class="language-vue">&lt;template&gt;
	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;
	&lt;h3&gt;{{keyword}}&lt;/h3&gt;
&lt;/template&gt;

&lt;script&gt;
	import {ref,customRef} from 'vue'
	export default {
		name:'Demo',
		setup(){
			// let keyword = ref('hello') //使用Vue准备好的内置ref
			//自定义一个myRef
			function myRef(value,delay){
				let timer
				//通过customRef去实现自定义
				return customRef((track,trigger)=&gt;{
					return{
						get(){
							track() //告诉Vue这个value值是需要被“追踪”的
							return value
						},
						set(newValue){
							clearTimeout(timer)
							timer = setTimeout(()=&gt;{
								value = newValue
								trigger() //告诉Vue去更新界面
							},delay)
						}
					}
				})
			}
			let keyword = myRef('hello',500) //使用程序员自定义的ref
			return {
				keyword
			}
		}
	}
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h2 id="5provide-与-inject">5.provide 与 inject</h2>
<img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />
<ul>
<li>
<p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li>
<p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li>
<p>具体写法：</p>
<ol>
<li>
<p>祖组件中：</p>
<pre><code class="language-js">setup(){
	......
    let car = reactive({name:'奔驰',price:'40万'})
    provide('car',car)
    ......
}
</code></pre>
</li>
<li>
<p>后代组件中：</p>
<pre><code class="language-js">setup(props,context){
	......
    const car = inject('car')
    return {car}
	......
}
</code></pre>
</li>
</ol>
</li>
</ul>
<h2 id="6响应式数据的判断">6.响应式数据的判断</h2>
<ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h1 id="四-composition-api-的优势">四、Composition API 的优势</h1>
<h2 id="1options-api-存在的问题">1.Options API 存在的问题</h2>
<p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<div style="width:600px;height:370px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" />
</div>
<div style="width:300px;height:370px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> 
</div>
<h2 id="2composition-api-的优势">2.Composition API 的优势</h2>
<p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
<div style="width:500px;height:340px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<div style="width:430px;height:340px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/>
</div>
<h1 id="五-新的组件">五、新的组件</h1>
<h2 id="1fragment">1.Fragment</h2>
<ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h2 id="2teleport">2.Teleport</h2>
<ul>
<li>
<p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<pre><code class="language-vue">&lt;teleport to=&quot;移动位置&quot;&gt;
	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;
		&lt;div class=&quot;dialog&quot;&gt;
			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;
			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/teleport&gt;
</code></pre>
</li>
</ul>
<h2 id="3suspense">3.Suspense</h2>
<ul>
<li>
<p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li>
<p>使用步骤：</p>
<ul>
<li>
<p>异步引入组件</p>
<pre><code class="language-js">import {defineAsyncComponent} from 'vue'
const Child = defineAsyncComponent(()=&gt;import('./components/Child.vue'))
</code></pre>
</li>
<li>
<p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<pre><code class="language-vue">&lt;template&gt;
	&lt;div class=&quot;app&quot;&gt;
		&lt;h3&gt;我是App组件&lt;/h3&gt;
		&lt;Suspense&gt;
			&lt;template v-slot:default&gt;
				&lt;Child/&gt;
			&lt;/template&gt;
			&lt;template v-slot:fallback&gt;
				&lt;h3&gt;加载中.....&lt;/h3&gt;
			&lt;/template&gt;
		&lt;/Suspense&gt;
	&lt;/div&gt;
&lt;/template&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="六-其他">六、其他</h1>
<h2 id="1全局api的转移">1.全局API的转移</h2>
<ul>
<li>
<p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li>
<p>例如：注册全局组件、注册全局指令等。</p>
<pre><code class="language-js">//注册全局组件
Vue.component('MyButton', {
  data: () =&gt; ({
    count: 0
  }),
  template: '&lt;button @click=&quot;count++&quot;&gt;Clicked {{ count }} times.&lt;/button&gt;'
})

//注册全局指令
Vue.directive('focus', {
  inserted: el =&gt; el.focus()
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li>
<p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h2 id="2其他改变">2.其他改变</h2>
<ul>
<li>
<p>data选项应始终被声明为一个函数。</p>
</li>
<li>
<p>过度类名的更改：</p>
<ul>
<li>
<p>Vue2.x写法</p>
<pre><code class="language-css">.v-enter,
.v-leave-to {
  opacity: 0;
}
.v-leave,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
<li>
<p>Vue3.x写法</p>
<pre><code class="language-css">.v-enter-from,
.v-leave-to {
  opacity: 0;
}

.v-leave-from,
.v-enter-to {
  opacity: 1;
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li>
<p>父组件中绑定事件</p>
<pre><code class="language-vue">&lt;my-component
  v-on:close=&quot;handleComponentEvent&quot;
  v-on:click=&quot;handleNativeClickEvent&quot;
/&gt;
</code></pre>
</li>
<li>
<p>子组件中声明自定义事件</p>
<pre><code class="language-vue">&lt;script&gt;
  export default {
    emits: ['close']
  }
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li>
<p>......</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript]]></title>
        <id>https://kingshuxin.github.io/post/typescript/</id>
        <link href="https://kingshuxin.github.io/post/typescript/">
        </link>
        <updated>2022-08-30T15:18:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="typescript">TypeScript</h1>
<h2 id="0-typescript简介">0、TypeScript简介</h2>
<ol>
<li>TypeScript是JavaScript的超集。</li>
<li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li>
<li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li>
<li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。</li>
<li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li>
</ol>
<h2 id="1-typescript-开发环境搭建">1、TypeScript 开发环境搭建</h2>
<ol>
<li>
<p>下载Node.js</p>
<ul>
<li>64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi</li>
<li>32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi</li>
</ul>
</li>
<li>
<p>安装Node.js</p>
</li>
<li>
<p>使用npm全局安装typescript</p>
<ul>
<li>进入命令行</li>
<li>输入：npm i -g typescript</li>
</ul>
</li>
<li>
<p>创建一个ts文件</p>
</li>
<li>
<p>使用tsc对ts文件进行编译</p>
<ul>
<li>
<p>进入命令行</p>
</li>
<li>
<p>进入ts文件所在目录</p>
</li>
<li>
<p>执行命令：tsc xxx.ts</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-基本类型">2、基本类型</h2>
<ul>
<li>
<p>类型声明</p>
<ul>
<li>
<p>类型声明是TS非常重要的一个特点</p>
</li>
<li>
<p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>
</li>
<li>
<p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
</li>
<li>
<p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p>
</li>
<li>
<p>语法：</p>
<ul>
<li>
<pre><code class="language-typescript">let 变量: 类型;

let 变量: 类型 = 值;

function fn(参数: 类型, 参数: 类型): 类型{
    ...
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>自动类型判断</p>
<ul>
<li>TS拥有自动的类型判断机制</li>
<li>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</li>
<li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li>
</ul>
</li>
<li>
<p>类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">number</td>
<td style="text-align:center">1, -33, 2.5</td>
<td style="text-align:center">任意数字</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">'hi', &quot;hi&quot;, <code>hi</code></td>
<td style="text-align:center">任意字符串</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">true、false</td>
<td style="text-align:center">布尔值true或false</td>
</tr>
<tr>
<td style="text-align:center">字面量</td>
<td style="text-align:center">其本身</td>
<td style="text-align:center">限制变量的值就是该字面量的值</td>
</tr>
<tr>
<td style="text-align:center">any</td>
<td style="text-align:center">*</td>
<td style="text-align:center">任意类型</td>
</tr>
<tr>
<td style="text-align:center">unknown</td>
<td style="text-align:center">*</td>
<td style="text-align:center">类型安全的any</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">空值（undefined）</td>
<td style="text-align:center">没有值（或undefined）</td>
</tr>
<tr>
<td style="text-align:center">never</td>
<td style="text-align:center">没有值</td>
<td style="text-align:center">不能是任何值</td>
</tr>
<tr>
<td style="text-align:center">object</td>
<td style="text-align:center">{name:'孙悟空'}</td>
<td style="text-align:center">任意的JS对象</td>
</tr>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">[1,2,3]</td>
<td style="text-align:center">任意JS数组</td>
</tr>
<tr>
<td style="text-align:center">tuple</td>
<td style="text-align:center">[4,5]</td>
<td style="text-align:center">元素，TS新增类型，固定长度数组</td>
</tr>
<tr>
<td style="text-align:center">enum</td>
<td style="text-align:center">enum{A, B}</td>
<td style="text-align:center">枚举，TS中新增类型</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>number</p>
<ul>
<li>
<pre><code class="language-typescript">let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
let big: bigint = 100n;
</code></pre>
</li>
</ul>
</li>
<li>
<p>boolean</p>
<ul>
<li>
<pre><code class="language-typescript">let isDone: boolean = false;
</code></pre>
</li>
</ul>
</li>
<li>
<p>string</p>
<ul>
<li>
<pre><code class="language-typescript">let color: string = &quot;blue&quot;;
color = 'red';

let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${fullName}.

I'll be ${age + 1} years old next month.`;
</code></pre>
</li>
</ul>
</li>
<li>
<p>字面量</p>
<ul>
<li>
<p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p>
</li>
<li>
<pre><code class="language-typescript">let color: 'red' | 'blue' | 'black';
let num: 1 | 2 | 3 | 4 | 5;
</code></pre>
</li>
</ul>
</li>
<li>
<p>any</p>
<ul>
<li>
<pre><code class="language-typescript">let d: any = 4;
d = 'hello';
d = true;
</code></pre>
</li>
</ul>
</li>
<li>
<p>unknown</p>
<ul>
<li>
<pre><code class="language-typescript">let notSure: unknown = 4;
notSure = 'hello';
</code></pre>
</li>
</ul>
</li>
<li>
<p>void</p>
<ul>
<li>
<pre><code class="language-typescript">let unusable: void = undefined;
</code></pre>
</li>
</ul>
</li>
<li>
<p>never</p>
<ul>
<li>
<pre><code class="language-typescript">function error(message: string): never {
  throw new Error(message);
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>object（没啥用）</p>
<ul>
<li>
<pre><code class="language-typescript">let obj: object = {};
</code></pre>
</li>
</ul>
</li>
<li>
<p>array</p>
<ul>
<li>
<pre><code class="language-typescript">let list: number[] = [1, 2, 3];
let list: Array&lt;number&gt; = [1, 2, 3];
</code></pre>
</li>
</ul>
</li>
<li>
<p>tuple</p>
<ul>
<li>
<pre><code class="language-typescript">let x: [string, number];
x = [&quot;hello&quot;, 10]; 
</code></pre>
</li>
</ul>
</li>
<li>
<p>enum</p>
<ul>
<li>
<pre><code class="language-typescript">enum Color {
  Red,
  Green,
  Blue,
}
let c: Color = Color.Green;

enum Color {
  Red = 1,
  Green,
  Blue,
}
let c: Color = Color.Green;

enum Color {
  Red = 1,
  Green = 2,
  Blue = 4,
}
let c: Color = Color.Green;
</code></pre>
</li>
</ul>
</li>
<li>
<p>类型断言</p>
<ul>
<li>
<p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p>
<ul>
<li>
<p>第一种</p>
<ul>
<li>
<pre><code class="language-typescript">let someValue: unknown = &quot;this is a string&quot;;
let strLength: number = (someValue as string).length;
</code></pre>
</li>
</ul>
</li>
<li>
<p>第二种</p>
<ul>
<li>
<pre><code class="language-typescript">let someValue: unknown = &quot;this is a string&quot;;
let strLength: number = (&lt;string&gt;someValue).length;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-编译选项">3、编译选项</h2>
<ul>
<li>
<p>自动编译文件</p>
<ul>
<li>
<p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-powershell">tsc xxx.ts -w
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>自动编译整个项目</p>
<ul>
<li>
<p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p>
</li>
<li>
<p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</p>
</li>
<li>
<p>tsconfig.json是一个JSON文件，添加配置文件后，只需 tsc 命令即可完成对整个项目的编译</p>
</li>
<li>
<p>配置选项：</p>
<ul>
<li>
<p>include</p>
<ul>
<li>
<p>定义希望被编译文件所在的目录</p>
</li>
<li>
<p>默认值：[&quot;**/*&quot;]</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]
</code></pre>
</li>
<li>
<p>上述示例中，所有src目录和tests目录下的文件都会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>exclude</p>
<ul>
<li>
<p>定义需要排除在外的目录</p>
</li>
<li>
<p>默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]
</code></pre>
</li>
<li>
<p>上述示例中，src下hello目录下的文件都不会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>extends</p>
<ul>
<li>
<p>定义被继承的配置文件</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;extends&quot;: &quot;./configs/base&quot;
</code></pre>
</li>
<li>
<p>上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>files</p>
<ul>
<li>
<p>指定被编译文件的列表，只有需要编译的文件少时才会用到</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;files&quot;: [
    &quot;core.ts&quot;,
    &quot;sys.ts&quot;,
    &quot;types.ts&quot;,
    &quot;scanner.ts&quot;,
    &quot;parser.ts&quot;,
    &quot;utilities.ts&quot;,
    &quot;binder.ts&quot;,
    &quot;checker.ts&quot;,
    &quot;tsc.ts&quot;
  ]
</code></pre>
</li>
<li>
<p>列表中的文件都会被TS编译器所编译</p>
</li>
</ul>
</li>
<li>
<p>compilerOptions</p>
<ul>
<li>
<p>编译选项是配置文件中非常重要也比较复杂的配置选项</p>
</li>
<li>
<p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>
<ul>
<li>
<p>项目选项</p>
<ul>
<li>
<p>target</p>
<ul>
<li>
<p>设置ts代码编译的目标版本</p>
</li>
<li>
<p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ES6&quot;
}
</code></pre>
</li>
<li>
<p>如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>lib</p>
<ul>
<li>
<p>指定代码运行时所包含的库（宿主环境）</p>
</li>
<li>
<p>可选值：</p>
<ul>
<li>ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ES6&quot;,
    &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],
    &quot;outDir&quot;: &quot;dist&quot;,
    &quot;outFile&quot;: &quot;dist/aa.js&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>module</p>
<ul>
<li>
<p>设置编译后代码使用的模块化系统</p>
</li>
<li>
<p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">&quot;compilerOptions&quot;: {
    &quot;module&quot;: &quot;CommonJS&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>outDir</p>
<ul>
<li>
<p>编译后文件的所在目录</p>
</li>
<li>
<p>默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;outDir&quot;: &quot;dist&quot;
}
</code></pre>
</li>
<li>
<p>设置后编译后的js文件将会生成到dist目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>outFile</p>
<ul>
<li>
<p>将所有的文件编译为一个js文件</p>
</li>
<li>
<p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;outFile&quot;: &quot;dist/app.js&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>rootDir</p>
<ul>
<li>
<p>指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;rootDir&quot;: &quot;./src&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>allowJs</p>
<ul>
<li>是否对js文件编译</li>
</ul>
</li>
<li>
<p>checkJs</p>
<ul>
<li>
<p>是否对js文件进行检查</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;allowJs&quot;: true,
    &quot;checkJs&quot;: true
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>removeComments</p>
<ul>
<li>是否删除注释</li>
<li>默认值：false</li>
</ul>
</li>
<li>
<p>noEmit</p>
<ul>
<li>不对代码进行编译</li>
<li>默认值：false</li>
</ul>
</li>
<li>
<p>sourceMap</p>
<ul>
<li>是否生成sourceMap</li>
<li>默认值：false</li>
</ul>
</li>
</ul>
</li>
<li>
<p>严格检查</p>
<ul>
<li>strict
<ul>
<li>启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</li>
</ul>
</li>
<li>alwaysStrict
<ul>
<li>总是以严格模式对代码进行编译</li>
</ul>
</li>
<li>noImplicitAny
<ul>
<li>禁止隐式的any类型</li>
</ul>
</li>
<li>noImplicitThis
<ul>
<li>禁止类型不明确的this</li>
</ul>
</li>
<li>strictBindCallApply
<ul>
<li>严格检查bind、call和apply的参数列表</li>
</ul>
</li>
<li>strictFunctionTypes
<ul>
<li>严格检查函数的类型</li>
</ul>
</li>
<li>strictNullChecks
<ul>
<li>严格的空值检查</li>
</ul>
</li>
<li>strictPropertyInitialization
<ul>
<li>严格检查属性是否初始化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>额外检查</p>
<ul>
<li>noFallthroughCasesInSwitch
<ul>
<li>检查switch语句包含正确的break</li>
</ul>
</li>
<li>noImplicitReturns
<ul>
<li>检查函数没有隐式的返回值</li>
</ul>
</li>
<li>noUnusedLocals
<ul>
<li>检查未使用的局部变量</li>
</ul>
</li>
<li>noUnusedParameters
<ul>
<li>检查未使用的参数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>高级</p>
<ul>
<li>allowUnreachableCode
<ul>
<li>检查不可达代码</li>
<li>可选值：
<ul>
<li>true，忽略不可达代码</li>
<li>false，不可达代码将引起错误</li>
</ul>
</li>
</ul>
</li>
<li>noEmitOnError
<ul>
<li>有错误的情况下不进行编译</li>
<li>默认值：false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-webpack">4、webpack</h2>
<ul>
<li>
<p>通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</p>
</li>
<li>
<p>步骤：</p>
<ol>
<li>
<p>初始化项目</p>
<ul>
<li>进入项目根目录，执行命令 <code> npm init -y</code>
<ul>
<li>主要作用：创建package.json文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>下载构建工具</p>
<ul>
<li><code>npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin</code>
<ul>
<li>共安装了7个包
<ul>
<li>webpack
<ul>
<li>构建工具webpack</li>
</ul>
</li>
<li>webpack-cli
<ul>
<li>webpack的命令行工具</li>
</ul>
</li>
<li>webpack-dev-server
<ul>
<li>webpack的开发服务器</li>
</ul>
</li>
<li>typescript
<ul>
<li>ts编译器</li>
</ul>
</li>
<li>ts-loader
<ul>
<li>ts加载器，用于在webpack中编译ts文件</li>
</ul>
</li>
<li>html-webpack-plugin
<ul>
<li>webpack中html插件，用来自动创建html文件</li>
</ul>
</li>
<li>clean-webpack-plugin
<ul>
<li>webpack中的清除插件，每次构建都会先清除目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>根目录下创建webpack的配置文件webpack.config.js</p>
<ul>
<li>
<pre><code class="language-javascript">const path = require(&quot;path&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;);

module.exports = {
    optimization:{
        minimize: false // 关闭代码压缩，可选
    },

    entry: &quot;./src/index.ts&quot;,
    
    devtool: &quot;inline-source-map&quot;,
    
    devServer: {
        contentBase: './dist'
    },

    output: {
        path: path.resolve(__dirname, &quot;dist&quot;),
        filename: &quot;bundle.js&quot;,
        environment: {
            arrowFunction: false // 关闭webpack的箭头函数，可选
        }
    },

    resolve: {
        extensions: [&quot;.ts&quot;, &quot;.js&quot;]
    },
    
    module: {
        rules: [
            {
                test: /\.ts$/,
                use: {
                   loader: &quot;ts-loader&quot;     
                },
                exclude: /node_modules/
            }
        ]
    },

    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'TS测试'
        }),
    ]

}
</code></pre>
</li>
</ul>
</li>
<li>
<p>根目录下创建tsconfig.json，配置可以根据自己需要</p>
<ul>
<li>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;ES2015&quot;,
        &quot;module&quot;: &quot;ES2015&quot;,
        &quot;strict&quot;: true
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>修改package.json添加如下配置</p>
<ul>
<li>
<pre><code class="language-json">{
  ...略...
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;
  },
  ...略...
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
</li>
</ul>
<h2 id="5-babel">5、Babel</h2>
<ul>
<li>
<p>经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。</p>
<ol>
<li>
<p>安装依赖包：</p>
<ul>
<li><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></li>
<li>共安装了4个包，分别是：
<ul>
<li>@babel/core
<ul>
<li>babel的核心工具</li>
</ul>
</li>
<li>@babel/preset-env
<ul>
<li>babel的预定义环境</li>
</ul>
</li>
<li>@babel-loader
<ul>
<li>babel在webpack中的加载器</li>
</ul>
</li>
<li>core-js
<ul>
<li>core-js用来使老版本的浏览器支持新版ES语法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>修改webpack.config.js配置文件</p>
<ul>
<li>
<pre><code class="language-javascript">...略...
module: {
    rules: [
        {
            test: /\.ts$/,
            use: [
                {
                    loader: &quot;babel-loader&quot;,
                    options:{
                        presets: [
                            [
                                &quot;@babel/preset-env&quot;,
                                {
                                    &quot;targets&quot;:{
                                        &quot;chrome&quot;: &quot;58&quot;,
                                        &quot;ie&quot;: &quot;11&quot;
                                    },
                                    &quot;corejs&quot;:&quot;3&quot;,
                                    &quot;useBuiltIns&quot;: &quot;usage&quot;
                                }
                            ]
                        ]
                    }
                },
                {
                    loader: &quot;ts-loader&quot;,

                }
            ],
            exclude: /node_modules/
        }
    ]
}
...略...
</code></pre>
</li>
<li>
<p>如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象]]></title>
        <id>https://kingshuxin.github.io/post/mian-xiang-dui-xiang/</id>
        <link href="https://kingshuxin.github.io/post/mian-xiang-dui-xiang/">
        </link>
        <updated>2022-08-30T15:01:32.000Z</updated>
        <content type="html"><![CDATA[<p>面向对象是程序中一个非常重要的思想，它被很多同学理解成了一个比较难，比较深奥的问题，其实不然。面向对象很简单，简而言之就是程序之中所有的操作都需要通过对象来完成。</p>
<ul>
<li>举例来说：
<ul>
<li>操作浏览器要使用window对象</li>
<li>操作网页要使用document对象</li>
<li>操作控制台要使用console对象</li>
</ul>
</li>
</ul>
<p>一切操作都要通过对象，也就是所谓的面向对象，那么对象到底是什么呢？这就要先说到程序是什么，计算机程序的本质就是对现实事物的抽象，抽象的反义词是具体，比如：照片是对一个具体的人的抽象，汽车模型是对具体汽车的抽象等等。程序也是对事物的抽象，在程序中我们可以表示一个人、一条狗、一把枪、一颗子弹等等所有的事物。一个事物到了程序中就变成了一个对象。</p>
<p>在程序中所有的对象都被分成了两个部分数据和功能，以人为例，人的姓名、性别、年龄、身高、体重等属于数据，人可以说话、走路、吃饭、睡觉这些属于人的功能。数据在对象中被成为属性，而功能就被称为方法。所以简而言之，在程序中一切皆是对象。</p>
<h2 id="1-类class">1、类（class）</h2>
<p>要想面向对象，操作对象，首先便要拥有对象，那么下一个问题就是如何创建对象。要创建对象，必须要先定义类，所谓的类可以理解为对象的模型，程序中可以根据类创建指定类型的对象，举例来说：可以通过Person类来创建人的对象，通过Dog类创建狗的对象，通过Car类来创建汽车的对象，不同的类可以用来创建不同的对象。</p>
<ul>
<li>
<p>定义类：</p>
<ul>
<li>
<pre><code class="language-typescript">class 类名 {
	属性名: 类型;
	
	constructor(参数: 类型){
		this.属性名 = 参数;
	}
	
	方法名(){
		....
	}

}
</code></pre>
</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">class Person{
    name: string;
    age: number;

    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>使用类：</p>
<ul>
<li>
<pre><code class="language-typescript">const p = new Person('孙悟空', 18);
p.sayHello();
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="2-面向对象的特点">2、面向对象的特点</h2>
<ul>
<li>
<p>封装</p>
<ul>
<li>
<p>对象实质上就是属性和方法的容器，它的主要作用就是存储属性和方法，这就是所谓的封装</p>
</li>
<li>
<p>默认情况下，对象的属性是可以任意的修改的，为了确保数据的安全性，在TS中可以对属性的权限进行设置</p>
</li>
<li>
<p>只读属性（readonly）：</p>
<ul>
<li>如果在声明属性时添加一个readonly，则属性便成了只读属性无法修改</li>
</ul>
</li>
<li>
<p>TS中属性具有三种修饰符：</p>
<ul>
<li>public（默认值），可以在类、子类和对象中修改</li>
<li>protected ，可以在类、子类中修改</li>
<li>private ，可以在类中修改</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<p>public</p>
<ul>
<li>
<pre><code class="language-typescript">class Person{
    public name: string; // 写或什么都不写都是public
    public age: number;

    constructor(name: string, age: number){
        this.name = name; // 可以在类中修改
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}

class Employee extends Person{
    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中可以修改
    }
}

const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 可以通过对象修改
</code></pre>
</li>
</ul>
</li>
<li>
<p>protected</p>
<ul>
<li>
<pre><code class="language-typescript">class Person{
    protected name: string;
    protected age: number;

    constructor(name: string, age: number){
        this.name = name; // 可以修改
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}

class Employee extends Person{

    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中可以修改
    }
}

const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 不能修改
</code></pre>
</li>
</ul>
</li>
<li>
<p>private</p>
<ul>
<li>
<pre><code class="language-typescript">class Person{
    private name: string;
    private age: number;

    constructor(name: string, age: number){
        this.name = name; // 可以修改
        this.age = age;
    }

    sayHello(){
        console.log(`大家好，我是${this.name}`);
    }
}

class Employee extends Person{

    constructor(name: string, age: number){
        super(name, age);
        this.name = name; //子类中不能修改
    }
}

const p = new Person('孙悟空', 18);
p.name = '猪八戒';// 不能修改
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>属性存取器</p>
<ul>
<li>
<p>对于一些不希望被任意修改的属性，可以将其设置为private</p>
</li>
<li>
<p>直接将其设置为private将导致无法再通过对象修改其中的属性</p>
</li>
<li>
<p>我们可以在类中定义一组读取、设置属性的方法，这种对属性读取或设置的属性被称为属性的存取器</p>
</li>
<li>
<p>读取属性的方法叫做setter方法，设置属性的方法叫做getter方法</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">class Person{
    private _name: string;

    constructor(name: string){
        this._name = name;
    }

    get name(){
        return this._name;
    }

    set name(name: string){
        this._name = name;
    }

}

const p1 = new Person('孙悟空');
console.log(p1.name); // 通过getter读取name属性
p1.name = '猪八戒'; // 通过setter修改name属性
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>静态属性</p>
<ul>
<li>
<p>静态属性（方法），也称为类属性。使用静态属性无需创建实例，通过类即可直接使用</p>
</li>
<li>
<p>静态属性（方法）使用static开头</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">class Tools{
    static PI = 3.1415926;
    
    static sum(num1: number, num2: number){
        return num1 + num2
    }
}

console.log(Tools.PI);
console.log(Tools.sum(123, 456));
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>this</p>
<ul>
<li>在类中，使用this表示当前对象</li>
</ul>
</li>
</ul>
</li>
<li>
<p>继承</p>
<ul>
<li>
<p>继承时面向对象中的又一个特性</p>
</li>
<li>
<p>通过继承可以将其他类中的属性和方法引入到当前类中</p>
<ul>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">class Animal{
    name: string;
    age: number;

    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }
}

class Dog extends Animal{

    bark(){
        console.log(`${this.name}在汪汪叫！`);
    }
}

const dog = new Dog('旺财', 4);
dog.bark();
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>通过继承可以在不修改类的情况下完成对类的扩展</p>
</li>
<li>
<p>重写</p>
<ul>
<li>
<p>发生继承时，如果子类中的方法会替换掉父类中的同名方法，这就称为方法的重写</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">class Animal{
    name: string;
    age: number;

    constructor(name: string, age: number){
        this.name = name;
        this.age = age;
    }

    run(){
        console.log(`父类中的run方法！`);
    }
}

class Dog extends Animal{

    bark(){
        console.log(`${this.name}在汪汪叫！`);
    }

    run(){
        console.log(`子类中的run方法，会重写父类中的run方法！`);
    }
}

const dog = new Dog('旺财', 4);
dog.bark();
</code></pre>
</li>
<li>
<p>在子类中可以使用super来完成对父类的引用</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>抽象类（abstract class）</p>
<ul>
<li>
<p>抽象类是专门用来被其他类所继承的类，它只能被其他类所继承不能用来创建实例</p>
</li>
<li>
<pre><code class="language-typescript">abstract class Animal{
    abstract run(): void;
    bark(){
        console.log('动物在叫~');
    }
}

class Dog extends Animals{
    run(){
        console.log('狗在跑~');
    }
}
</code></pre>
</li>
<li>
<p>使用abstract开头的方法叫做抽象方法，抽象方法没有方法体只能定义在抽象类中，继承抽象类时抽象方法必须要实现</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-接口interface">3、接口（Interface）</h2>
<p>接口的作用类似于抽象类，不同点在于接口中的所有方法和属性都是没有实值的，换句话说接口中的所有方法都是抽象方法。接口主要负责定义一个类的结构，接口可以去限制一个对象的接口，对象只有包含接口中定义的所有属性和方法时才能匹配接口。同时，可以让一个类去实现接口，实现接口时类中要保护接口中的所有属性。</p>
<ul>
<li>
<p>示例（检查对象类型）：</p>
<ul>
<li>
<pre><code class="language-typescript">interface Person{
    name: string;
    sayHello():void;
}

function fn(per: Person){
    per.sayHello();
}

fn({name:'孙悟空', sayHello() {console.log(`Hello, 我是 ${this.name}`)}});

</code></pre>
</li>
</ul>
</li>
<li>
<p>示例（实现）</p>
<ul>
<li>
<pre><code class="language-typescript">interface Person{
    name: string;
    sayHello():void;
}

class Student implements Person{
    constructor(public name: string) {
    }

    sayHello() {
        console.log('大家好，我是'+this.name);
    }
}
</code></pre>
</li>
<li></li>
</ul>
</li>
</ul>
<h2 id="4-泛型generic">4、泛型（Generic）</h2>
<p>定义一个函数或类时，有些情况下无法确定其中要使用的具体类型（返回值、参数、属性的类型不能确定），此时泛型便能够发挥作用。</p>
<ul>
<li>
<p>举个例子：</p>
<ul>
<li>
<pre><code class="language-typescript">function test(arg: any): any{
	return arg;
}
</code></pre>
</li>
<li>
<p>上例中，test函数有一个参数类型不确定，但是能确定的时其返回值的类型和参数的类型是相同的，由于类型不确定所以参数和返回值均使用了any，但是很明显这样做是不合适的，首先使用any会关闭TS的类型检查，其次这样设置也不能体现出参数和返回值是相同的类型</p>
</li>
<li>
<p>使用泛型：</p>
</li>
<li>
<pre><code class="language-typescript">function test&lt;T&gt;(arg: T): T{
	return arg;
}
</code></pre>
</li>
<li>
<p>这里的<code>&lt;T&gt;</code>就是泛型，T是我们给这个类型起的名字（不一定非叫T），设置泛型后即可在函数中使用T来表示该类型。所以泛型其实很好理解，就表示某个类型。</p>
</li>
<li>
<p>那么如何使用上边的函数呢？</p>
<ul>
<li>
<p>方式一（直接使用）：</p>
<ul>
<li>
<pre><code class="language-typescript">test(10)
</code></pre>
</li>
<li>
<p>使用时可以直接传递参数使用，类型会由TS自动推断出来，但有时编译器无法自动推断时还需要使用下面的方式</p>
</li>
</ul>
</li>
<li>
<p>方式二（指定类型）：</p>
<ul>
<li>
<pre><code class="language-typescript">test&lt;number&gt;(10)
</code></pre>
</li>
<li>
<p>也可以在函数后手动指定泛型</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>可以同时指定多个泛型，泛型间使用逗号隔开：</p>
<ul>
<li>
<pre><code class="language-typescript">function test&lt;T, K&gt;(a: T, b: K): K{
    return b;
}

test&lt;number, string&gt;(10, &quot;hello&quot;);
</code></pre>
</li>
<li>
<p>使用泛型时，完全可以将泛型当成是一个普通的类去使用</p>
</li>
</ul>
</li>
<li>
<p>类中同样可以使用泛型：</p>
<ul>
<li>
<pre><code class="language-typescript">class MyClass&lt;T&gt;{
    prop: T;

    constructor(prop: T){
        this.prop = prop;
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>除此之外，也可以对泛型的范围进行约束</p>
<ul>
<li>
<pre><code class="language-typescript">interface MyInter{
    length: number;
}

function test&lt;T extends MyInter&gt;(arg: T): number{
    return arg.length;
}
</code></pre>
</li>
<li>
<p>使用T extends MyInter表示泛型T必须是MyInter的子类，不一定非要使用接口类和抽象类同样适用。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>TypeScript | Hsx</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://kingshuxin.github.io/favicon.ico?v=1664238670307">
<link rel="stylesheet" href="https://kingshuxin.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="TypeScript
0、TypeScript简介

TypeScript是JavaScript的超集。
它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。
TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。
T..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://kingshuxin.github.io">
        <img src="https://kingshuxin.github.io/images/avatar.png?v=1664238670307" class="site-logo">
        <h1 class="site-title">Hsx</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Follow your heart.
    </div>
    <div class="site-footer">
      ❤路敏雪 | <a class="rss" href="https://kingshuxin.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">TypeScript</h2>
            <div class="post-date">2022-08-30</div>
            
            <div class="post-content" v-pre>
              <h1 id="typescript">TypeScript</h1>
<h2 id="0-typescript简介">0、TypeScript简介</h2>
<ol>
<li>TypeScript是JavaScript的超集。</li>
<li>它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。</li>
<li>TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。</li>
<li>TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。</li>
<li>相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。</li>
</ol>
<h2 id="1-typescript-开发环境搭建">1、TypeScript 开发环境搭建</h2>
<ol>
<li>
<p>下载Node.js</p>
<ul>
<li>64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi</li>
<li>32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi</li>
</ul>
</li>
<li>
<p>安装Node.js</p>
</li>
<li>
<p>使用npm全局安装typescript</p>
<ul>
<li>进入命令行</li>
<li>输入：npm i -g typescript</li>
</ul>
</li>
<li>
<p>创建一个ts文件</p>
</li>
<li>
<p>使用tsc对ts文件进行编译</p>
<ul>
<li>
<p>进入命令行</p>
</li>
<li>
<p>进入ts文件所在目录</p>
</li>
<li>
<p>执行命令：tsc xxx.ts</p>
</li>
</ul>
</li>
</ol>
<h2 id="2-基本类型">2、基本类型</h2>
<ul>
<li>
<p>类型声明</p>
<ul>
<li>
<p>类型声明是TS非常重要的一个特点</p>
</li>
<li>
<p>通过类型声明可以指定TS中变量（参数、形参）的类型</p>
</li>
<li>
<p>指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错</p>
</li>
<li>
<p>简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值</p>
</li>
<li>
<p>语法：</p>
<ul>
<li>
<pre><code class="language-typescript">let 变量: 类型;

let 变量: 类型 = 值;

function fn(参数: 类型, 参数: 类型): 类型{
    ...
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>自动类型判断</p>
<ul>
<li>TS拥有自动的类型判断机制</li>
<li>当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型</li>
<li>所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明</li>
</ul>
</li>
<li>
<p>类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">例子</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">number</td>
<td style="text-align:center">1, -33, 2.5</td>
<td style="text-align:center">任意数字</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">'hi', &quot;hi&quot;, <code>hi</code></td>
<td style="text-align:center">任意字符串</td>
</tr>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">true、false</td>
<td style="text-align:center">布尔值true或false</td>
</tr>
<tr>
<td style="text-align:center">字面量</td>
<td style="text-align:center">其本身</td>
<td style="text-align:center">限制变量的值就是该字面量的值</td>
</tr>
<tr>
<td style="text-align:center">any</td>
<td style="text-align:center">*</td>
<td style="text-align:center">任意类型</td>
</tr>
<tr>
<td style="text-align:center">unknown</td>
<td style="text-align:center">*</td>
<td style="text-align:center">类型安全的any</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">空值（undefined）</td>
<td style="text-align:center">没有值（或undefined）</td>
</tr>
<tr>
<td style="text-align:center">never</td>
<td style="text-align:center">没有值</td>
<td style="text-align:center">不能是任何值</td>
</tr>
<tr>
<td style="text-align:center">object</td>
<td style="text-align:center">{name:'孙悟空'}</td>
<td style="text-align:center">任意的JS对象</td>
</tr>
<tr>
<td style="text-align:center">array</td>
<td style="text-align:center">[1,2,3]</td>
<td style="text-align:center">任意JS数组</td>
</tr>
<tr>
<td style="text-align:center">tuple</td>
<td style="text-align:center">[4,5]</td>
<td style="text-align:center">元素，TS新增类型，固定长度数组</td>
</tr>
<tr>
<td style="text-align:center">enum</td>
<td style="text-align:center">enum{A, B}</td>
<td style="text-align:center">枚举，TS中新增类型</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>number</p>
<ul>
<li>
<pre><code class="language-typescript">let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
let big: bigint = 100n;
</code></pre>
</li>
</ul>
</li>
<li>
<p>boolean</p>
<ul>
<li>
<pre><code class="language-typescript">let isDone: boolean = false;
</code></pre>
</li>
</ul>
</li>
<li>
<p>string</p>
<ul>
<li>
<pre><code class="language-typescript">let color: string = &quot;blue&quot;;
color = 'red';

let fullName: string = `Bob Bobbington`;
let age: number = 37;
let sentence: string = `Hello, my name is ${fullName}.

I'll be ${age + 1} years old next month.`;
</code></pre>
</li>
</ul>
</li>
<li>
<p>字面量</p>
<ul>
<li>
<p>也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围</p>
</li>
<li>
<pre><code class="language-typescript">let color: 'red' | 'blue' | 'black';
let num: 1 | 2 | 3 | 4 | 5;
</code></pre>
</li>
</ul>
</li>
<li>
<p>any</p>
<ul>
<li>
<pre><code class="language-typescript">let d: any = 4;
d = 'hello';
d = true;
</code></pre>
</li>
</ul>
</li>
<li>
<p>unknown</p>
<ul>
<li>
<pre><code class="language-typescript">let notSure: unknown = 4;
notSure = 'hello';
</code></pre>
</li>
</ul>
</li>
<li>
<p>void</p>
<ul>
<li>
<pre><code class="language-typescript">let unusable: void = undefined;
</code></pre>
</li>
</ul>
</li>
<li>
<p>never</p>
<ul>
<li>
<pre><code class="language-typescript">function error(message: string): never {
  throw new Error(message);
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>object（没啥用）</p>
<ul>
<li>
<pre><code class="language-typescript">let obj: object = {};
</code></pre>
</li>
</ul>
</li>
<li>
<p>array</p>
<ul>
<li>
<pre><code class="language-typescript">let list: number[] = [1, 2, 3];
let list: Array&lt;number&gt; = [1, 2, 3];
</code></pre>
</li>
</ul>
</li>
<li>
<p>tuple</p>
<ul>
<li>
<pre><code class="language-typescript">let x: [string, number];
x = [&quot;hello&quot;, 10]; 
</code></pre>
</li>
</ul>
</li>
<li>
<p>enum</p>
<ul>
<li>
<pre><code class="language-typescript">enum Color {
  Red,
  Green,
  Blue,
}
let c: Color = Color.Green;

enum Color {
  Red = 1,
  Green,
  Blue,
}
let c: Color = Color.Green;

enum Color {
  Red = 1,
  Green = 2,
  Blue = 4,
}
let c: Color = Color.Green;
</code></pre>
</li>
</ul>
</li>
<li>
<p>类型断言</p>
<ul>
<li>
<p>有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式：</p>
<ul>
<li>
<p>第一种</p>
<ul>
<li>
<pre><code class="language-typescript">let someValue: unknown = &quot;this is a string&quot;;
let strLength: number = (someValue as string).length;
</code></pre>
</li>
</ul>
</li>
<li>
<p>第二种</p>
<ul>
<li>
<pre><code class="language-typescript">let someValue: unknown = &quot;this is a string&quot;;
let strLength: number = (&lt;string&gt;someValue).length;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-编译选项">3、编译选项</h2>
<ul>
<li>
<p>自动编译文件</p>
<ul>
<li>
<p>编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-powershell">tsc xxx.ts -w
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>自动编译整个项目</p>
<ul>
<li>
<p>如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。</p>
</li>
<li>
<p>但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json</p>
</li>
<li>
<p>tsconfig.json是一个JSON文件，添加配置文件后，只需 tsc 命令即可完成对整个项目的编译</p>
</li>
<li>
<p>配置选项：</p>
<ul>
<li>
<p>include</p>
<ul>
<li>
<p>定义希望被编译文件所在的目录</p>
</li>
<li>
<p>默认值：[&quot;**/*&quot;]</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;include&quot;:[&quot;src/**/*&quot;, &quot;tests/**/*&quot;]
</code></pre>
</li>
<li>
<p>上述示例中，所有src目录和tests目录下的文件都会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>exclude</p>
<ul>
<li>
<p>定义需要排除在外的目录</p>
</li>
<li>
<p>默认值：[&quot;node_modules&quot;, &quot;bower_components&quot;, &quot;jspm_packages&quot;]</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;exclude&quot;: [&quot;./src/hello/**/*&quot;]
</code></pre>
</li>
<li>
<p>上述示例中，src下hello目录下的文件都不会被编译</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>extends</p>
<ul>
<li>
<p>定义被继承的配置文件</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;extends&quot;: &quot;./configs/base&quot;
</code></pre>
</li>
<li>
<p>上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>files</p>
<ul>
<li>
<p>指定被编译文件的列表，只有需要编译的文件少时才会用到</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;files&quot;: [
    &quot;core.ts&quot;,
    &quot;sys.ts&quot;,
    &quot;types.ts&quot;,
    &quot;scanner.ts&quot;,
    &quot;parser.ts&quot;,
    &quot;utilities.ts&quot;,
    &quot;binder.ts&quot;,
    &quot;checker.ts&quot;,
    &quot;tsc.ts&quot;
  ]
</code></pre>
</li>
<li>
<p>列表中的文件都会被TS编译器所编译</p>
</li>
</ul>
</li>
<li>
<p>compilerOptions</p>
<ul>
<li>
<p>编译选项是配置文件中非常重要也比较复杂的配置选项</p>
</li>
<li>
<p>在compilerOptions中包含多个子选项，用来完成对编译的配置</p>
<ul>
<li>
<p>项目选项</p>
<ul>
<li>
<p>target</p>
<ul>
<li>
<p>设置ts代码编译的目标版本</p>
</li>
<li>
<p>可选值：</p>
<ul>
<li>ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ES6&quot;
}
</code></pre>
</li>
<li>
<p>如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>lib</p>
<ul>
<li>
<p>指定代码运行时所包含的库（宿主环境）</p>
</li>
<li>
<p>可选值：</p>
<ul>
<li>ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ......</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;ES6&quot;,
    &quot;lib&quot;: [&quot;ES6&quot;, &quot;DOM&quot;],
    &quot;outDir&quot;: &quot;dist&quot;,
    &quot;outFile&quot;: &quot;dist/aa.js&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>module</p>
<ul>
<li>
<p>设置编译后代码使用的模块化系统</p>
</li>
<li>
<p>可选值：</p>
<ul>
<li>CommonJS、UMD、AMD、System、ES2020、ESNext、None</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-typescript">&quot;compilerOptions&quot;: {
    &quot;module&quot;: &quot;CommonJS&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>outDir</p>
<ul>
<li>
<p>编译后文件的所在目录</p>
</li>
<li>
<p>默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;outDir&quot;: &quot;dist&quot;
}
</code></pre>
</li>
<li>
<p>设置后编译后的js文件将会生成到dist目录</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>outFile</p>
<ul>
<li>
<p>将所有的文件编译为一个js文件</p>
</li>
<li>
<p>默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;outFile&quot;: &quot;dist/app.js&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>rootDir</p>
<ul>
<li>
<p>指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;rootDir&quot;: &quot;./src&quot;
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>allowJs</p>
<ul>
<li>是否对js文件编译</li>
</ul>
</li>
<li>
<p>checkJs</p>
<ul>
<li>
<p>是否对js文件进行检查</p>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<pre><code class="language-json">&quot;compilerOptions&quot;: {
    &quot;allowJs&quot;: true,
    &quot;checkJs&quot;: true
}
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>removeComments</p>
<ul>
<li>是否删除注释</li>
<li>默认值：false</li>
</ul>
</li>
<li>
<p>noEmit</p>
<ul>
<li>不对代码进行编译</li>
<li>默认值：false</li>
</ul>
</li>
<li>
<p>sourceMap</p>
<ul>
<li>是否生成sourceMap</li>
<li>默认值：false</li>
</ul>
</li>
</ul>
</li>
<li>
<p>严格检查</p>
<ul>
<li>strict
<ul>
<li>启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查</li>
</ul>
</li>
<li>alwaysStrict
<ul>
<li>总是以严格模式对代码进行编译</li>
</ul>
</li>
<li>noImplicitAny
<ul>
<li>禁止隐式的any类型</li>
</ul>
</li>
<li>noImplicitThis
<ul>
<li>禁止类型不明确的this</li>
</ul>
</li>
<li>strictBindCallApply
<ul>
<li>严格检查bind、call和apply的参数列表</li>
</ul>
</li>
<li>strictFunctionTypes
<ul>
<li>严格检查函数的类型</li>
</ul>
</li>
<li>strictNullChecks
<ul>
<li>严格的空值检查</li>
</ul>
</li>
<li>strictPropertyInitialization
<ul>
<li>严格检查属性是否初始化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>额外检查</p>
<ul>
<li>noFallthroughCasesInSwitch
<ul>
<li>检查switch语句包含正确的break</li>
</ul>
</li>
<li>noImplicitReturns
<ul>
<li>检查函数没有隐式的返回值</li>
</ul>
</li>
<li>noUnusedLocals
<ul>
<li>检查未使用的局部变量</li>
</ul>
</li>
<li>noUnusedParameters
<ul>
<li>检查未使用的参数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>高级</p>
<ul>
<li>allowUnreachableCode
<ul>
<li>检查不可达代码</li>
<li>可选值：
<ul>
<li>true，忽略不可达代码</li>
<li>false，不可达代码将引起错误</li>
</ul>
</li>
</ul>
</li>
<li>noEmitOnError
<ul>
<li>有错误的情况下不进行编译</li>
<li>默认值：false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-webpack">4、webpack</h2>
<ul>
<li>
<p>通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。</p>
</li>
<li>
<p>步骤：</p>
<ol>
<li>
<p>初始化项目</p>
<ul>
<li>进入项目根目录，执行命令 <code> npm init -y</code>
<ul>
<li>主要作用：创建package.json文件</li>
</ul>
</li>
</ul>
</li>
<li>
<p>下载构建工具</p>
<ul>
<li><code>npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin</code>
<ul>
<li>共安装了7个包
<ul>
<li>webpack
<ul>
<li>构建工具webpack</li>
</ul>
</li>
<li>webpack-cli
<ul>
<li>webpack的命令行工具</li>
</ul>
</li>
<li>webpack-dev-server
<ul>
<li>webpack的开发服务器</li>
</ul>
</li>
<li>typescript
<ul>
<li>ts编译器</li>
</ul>
</li>
<li>ts-loader
<ul>
<li>ts加载器，用于在webpack中编译ts文件</li>
</ul>
</li>
<li>html-webpack-plugin
<ul>
<li>webpack中html插件，用来自动创建html文件</li>
</ul>
</li>
<li>clean-webpack-plugin
<ul>
<li>webpack中的清除插件，每次构建都会先清除目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>根目录下创建webpack的配置文件webpack.config.js</p>
<ul>
<li>
<pre><code class="language-javascript">const path = require(&quot;path&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
const { CleanWebpackPlugin } = require(&quot;clean-webpack-plugin&quot;);

module.exports = {
    optimization:{
        minimize: false // 关闭代码压缩，可选
    },

    entry: &quot;./src/index.ts&quot;,
    
    devtool: &quot;inline-source-map&quot;,
    
    devServer: {
        contentBase: './dist'
    },

    output: {
        path: path.resolve(__dirname, &quot;dist&quot;),
        filename: &quot;bundle.js&quot;,
        environment: {
            arrowFunction: false // 关闭webpack的箭头函数，可选
        }
    },

    resolve: {
        extensions: [&quot;.ts&quot;, &quot;.js&quot;]
    },
    
    module: {
        rules: [
            {
                test: /\.ts$/,
                use: {
                   loader: &quot;ts-loader&quot;     
                },
                exclude: /node_modules/
            }
        ]
    },

    plugins: [
        new CleanWebpackPlugin(),
        new HtmlWebpackPlugin({
            title:'TS测试'
        }),
    ]

}
</code></pre>
</li>
</ul>
</li>
<li>
<p>根目录下创建tsconfig.json，配置可以根据自己需要</p>
<ul>
<li>
<pre><code class="language-json">{
    &quot;compilerOptions&quot;: {
        &quot;target&quot;: &quot;ES2015&quot;,
        &quot;module&quot;: &quot;ES2015&quot;,
        &quot;strict&quot;: true
    }
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>修改package.json添加如下配置</p>
<ul>
<li>
<pre><code class="language-json">{
  ...略...
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;start&quot;: &quot;webpack serve --open chrome.exe&quot;
  },
  ...略...
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>在src下创建ts文件，并在并命令行执行<code>npm run build</code>对代码进行编译，或者执行<code>npm start</code>来启动开发服务器</p>
</li>
</ol>
</li>
</ul>
<h2 id="5-babel">5、Babel</h2>
<ul>
<li>
<p>经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。</p>
<ol>
<li>
<p>安装依赖包：</p>
<ul>
<li><code>npm i -D @babel/core @babel/preset-env babel-loader core-js</code></li>
<li>共安装了4个包，分别是：
<ul>
<li>@babel/core
<ul>
<li>babel的核心工具</li>
</ul>
</li>
<li>@babel/preset-env
<ul>
<li>babel的预定义环境</li>
</ul>
</li>
<li>@babel-loader
<ul>
<li>babel在webpack中的加载器</li>
</ul>
</li>
<li>core-js
<ul>
<li>core-js用来使老版本的浏览器支持新版ES语法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>修改webpack.config.js配置文件</p>
<ul>
<li>
<pre><code class="language-javascript">...略...
module: {
    rules: [
        {
            test: /\.ts$/,
            use: [
                {
                    loader: &quot;babel-loader&quot;,
                    options:{
                        presets: [
                            [
                                &quot;@babel/preset-env&quot;,
                                {
                                    &quot;targets&quot;:{
                                        &quot;chrome&quot;: &quot;58&quot;,
                                        &quot;ie&quot;: &quot;11&quot;
                                    },
                                    &quot;corejs&quot;:&quot;3&quot;,
                                    &quot;useBuiltIns&quot;: &quot;usage&quot;
                                }
                            ]
                        ]
                    }
                },
                {
                    loader: &quot;ts-loader&quot;,

                }
            ],
            exclude: /node_modules/
        }
    ]
}
...略...
</code></pre>
</li>
<li>
<p>如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://kingshuxin.github.io/post/mian-xiang-dui-xiang/">
                  <h3 class="post-title">
                    面向对象
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Vue | Hsx</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://kingshuxin.github.io/favicon.ico?v=1664238670307">
<link rel="stylesheet" href="https://kingshuxin.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="vue
基础
初识Vue：
​        1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；
​        2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；
​        3.r..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://kingshuxin.github.io">
        <img src="https://kingshuxin.github.io/images/avatar.png?v=1664238670307" class="site-logo">
        <h1 class="site-title">Hsx</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Follow your heart.
    </div>
    <div class="site-footer">
      ❤路敏雪 | <a class="rss" href="https://kingshuxin.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Vue</h2>
            <div class="post-date">2022-08-30</div>
            
            <div class="post-content" v-pre>
              <h1 id="vue">vue</h1>
<h2 id="基础">基础</h2>
<p>初识Vue：</p>
<p>​        1.想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；</p>
<p>​        2.root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法；</p>
<p>​        3.root容器里的代码被称为【Vue模板】；</p>
<p>​        4.Vue实例和容器是一一对应的；</p>
<p>​        5.真实开发中只有一个Vue实例，并且会配合着组件一起使用；</p>
<p>​        6.{{xxx}}中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性；</p>
<p>​        7.一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新；</p>
<p>注意区分：js表达式 和 js代码(语句)</p>
<p>​            1.表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方</p>
<pre><code class="language-js"> (1). a

​(2). a+b                  

​(3). demo(1)                  

​(4). x === y ? 'a' : 'b                  
</code></pre>
<p>​            2.js代码(语句)</p>
<pre><code class="language-js">(1). if(){}

​(2). for(){}
</code></pre>
<p>Vue模板语法有2大类：</p>
<p>​          1.插值语法：</p>
<p>​              功能：用于解析标签体内容。</p>
<p>​              写法：{{xxx}}，xxx是js表达式，且可以直接读取到data中的所有属性。</p>
<p>​          2.指令语法：</p>
<p>​              功能：用于解析标签（包括：标签属性、标签体内容、绑定事件.....）。</p>
<p>​              举例：v-bind:href=&quot;xxx&quot; 或  简写为 :href=&quot;xxx&quot;，xxx同样要写js表达式，</p>
<p>​                   且可以直接读取到data中的所有属性。</p>
<p>Vue中有2种数据绑定的方式：</p>
<p>​          1.单向绑定(v-bind)：数据只能从data流向页面。</p>
<p>​          2.双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。</p>
<p>​            备注：</p>
<p>​                1.双向绑定一般都应用在表单类元素上（如：input、select等）</p>
<p>​                2.v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。</p>
<pre><code class="language-js">&lt;!-- 简写 --&gt;
			单向数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt;
			双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt;
</code></pre>
<p>data与el的2种写法</p>
<p>​          1.el有2种写法</p>
<p>​                  (1).new Vue时候配置el属性。</p>
<p>​                  (2).先创建Vue实例，随后再通过vm.$mount('#root')指定el的值。</p>
<p>​          2.data有2种写法</p>
<p>​                  (1).对象式</p>
<p>​                  (2).函数式</p>
<p>​                  如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。</p>
<p>​          3.一个重要的原则：</p>
<p>​                  由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。</p>
<h2 id="mvvm模型">MVVM模型</h2>
<p>MVVM模型</p>
<ol>
<li>​            \1. M：模型(Model) ：data中的数据</li>
<li>​            \2. V：视图(View) ：模板代码</li>
<li>​            \3. VM：视图模型(ViewModel)：Vue实例</li>
</ol>
<p>​      观察发现：</p>
<p>​            1.data中所有的属性，最后都出现在了vm身上。</p>
<p>​            2.vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。</p>
<h2 id="数据代理">数据代理</h2>
<p>1.Vue中的数据代理：</p>
<p>​              通过vm对象来代理data对象中属性的操作（读/写）</p>
<p>2.Vue中数据代理的好处：</p>
<p>​              更加方便的操作data中的数据</p>
<p>3.基本原理：</p>
<p>​              通过Object.defineProperty()把data对象中所有属性添加到vm上。</p>
<p>​              为每一个添加到vm上的属性，都指定一个getter/setter。</p>
<p>​              在getter/setter内部去操作（读/写）data中对应的属性。</p>
<h2 id="事件处理">事件处理</h2>
<h3 id="基本使用">基本使用</h3>
<p>​              1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；</p>
<p>​              2.事件的回调需要配置在methods对象中，最终会在vm上；</p>
<p>​              3.methods中配置的函数，不要用箭头函数！否则this就不是vm了；</p>
<p>​              4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；</p>
<p>​              5.@click=&quot;demo&quot; 和 @click=&quot;demo($event)&quot; 效果一致，但后者可以传参；</p>
<h3 id="事件修饰符">事件修饰符：</h3>
<p>​            1.prevent：阻止默认事件（常用）；</p>
<p>​            2.stop：阻止事件冒泡（常用）；</p>
<p>​            3.once：事件只触发一次（常用）；</p>
<p>​            4.capture：使用事件的捕获模式；</p>
<p>​            5.self：只有event.target是当前操作的元素时才触发事件；</p>
<p>​            6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；</p>
<h3 id="键盘事件">键盘事件</h3>
<p>1.Vue中常用的按键别名：</p>
<p>​              回车 =&gt; enter</p>
<p>​              删除 =&gt; delete (捕获“删除”和“退格”键)</p>
<p>​              退出 =&gt; esc</p>
<p>​              空格 =&gt; space</p>
<p>​              换行 =&gt; tab (特殊，必须配合keydown去使用)</p>
<p>​              上 =&gt; up</p>
<p>​              下 =&gt; down</p>
<p>​              左 =&gt; left</p>
<p>​              右 =&gt; right</p>
<p>​        2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）</p>
<p>​        3.系统修饰键（用法特殊）：ctrl、alt、shift、meta</p>
<p>​              (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。</p>
<p>​              (2).配合keydown使用：正常触发事件。</p>
<p>​        4.也可以使用keyCode去指定具体的按键（不推荐）</p>
<p>​        5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名</p>
<h2 id="计算属性">计算属性</h2>
<h3 id="计算属性-2">计算属性：</h3>
<p>​          1.定义：要用的属性不存在，要通过已有属性计算得来。</p>
<p>​          2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。</p>
<p>​          3.get函数什么时候执行？</p>
<p>​                (1).初次读取时会执行一次。</p>
<p>​                (2).当依赖的数据发生改变时会被再次调用。</p>
<p>​          4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。</p>
<p>​          5.备注：</p>
<p>​              1.计算属性最终会出现在vm上，直接读取使用即可。</p>
<p>​              2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。</p>
<pre><code class="language-js">computed:{
    fullName:{
        //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值
        //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。
        get(){
            console.log('get被调用了')
            // console.log(this) //此处的this是vm
            return this.firstName + '-' + this.lastName
        },
        //set什么时候调用? 当fullName被修改时。
        set(value){
            console.log('set',value)
            const arr = value.split('-')
            this.firstName = arr[0]
            this.lastName = arr[1]
         }
    }
}
</code></pre>
<p>只有get时，可以简写</p>
<pre><code class="language-js">//简写
fullName(){
	console.log('get被调用了')
	return this.firstName + '-' + this.lastName
}
</code></pre>
<h2 id="监视属性">监视属性</h2>
<h3 id="监视属性watch">监视属性watch：</h3>
<p>​          1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作</p>
<p>​          2.监视的属性必须存在，才能进行监视！！</p>
<p>​          3.监视的两种写法：</p>
<p>​              (1).new Vue时传入watch配置</p>
<p>​              (2).通过vm.$watch监视</p>
<pre><code class="language-js">watch:{
    isHot:{
        immediate:true, //初始化时让handler调用一下
        //handler什么时候调用？当isHot发生改变时。
        handler(newValue,oldValue){
        console.log('isHot被修改了',newValue,oldValue)
    }
}
</code></pre>
<pre><code class="language-js">vm.$watch('isHot',{
    immediate:true, //初始化时让handler调用一下
    //handler什么时候调用？当isHot发生改变时。
    handler(newValue,oldValue){
    console.log('isHot被修改了',newValue,oldValue)
    }
})
</code></pre>
<h3 id="深度监视">深度监视：</h3>
<p>​            (1).Vue中的watch默认不监测对象内部值的改变（一层）。</p>
<p>​            (2).配置deep:true可以监测对象内部值改变（多层）。</p>
<h3 id="computed对比watch">computed对比watch</h3>
<p>computed和watch之间的区别：</p>
<p>​            1.computed能完成的功能，watch都可以完成。</p>
<p>​            2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。</p>
<p><strong>两个重要的小原则</strong>：</p>
<p>​              1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。</p>
<p>​              2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。</p>
<h2 id="绑定样式">绑定样式</h2>
<p>\1. class样式</p>
<p>​                写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。</p>
<p>​                    字符串写法适用于：类名不确定，要动态获取。</p>
<p>​                    对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。</p>
<p>​                    数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。</p>
<p>​          \2. style样式</p>
<p>​                :style=&quot;{fontSize: xxx}&quot;其中xxx是动态值。</p>
<p>​                :style=&quot;[a,b]&quot;其中a、b是样式对象。</p>
<h2 id="条件渲染">条件渲染</h2>
<p>条件渲染：</p>
<p>​              1.v-if</p>
<p>​                    写法：</p>
<p>​                        (1).v-if=&quot;表达式&quot;</p>
<p>​                        (2).v-else-if=&quot;表达式&quot;</p>
<p>​                        (3).v-else=&quot;表达式&quot;</p>
<p>​                    适用于：切换频率较低的场景。</p>
<p>​                    特点：不展示的DOM元素直接被移除。</p>
<p>​                    注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。</p>
<p>​              2.v-show</p>
<p>​                    写法：v-show=&quot;表达式&quot;</p>
<p>​                    适用于：切换频率较高的场景。</p>
<p>​                    特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉</p>
<p>​</p>
<p>​              3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。</p>
<p>​				template只能和v-if配合使用</p>
<h2 id="列表渲染">列表渲染</h2>
<h3 id="v-for指令">v-for指令:</h3>
<p>​            1.用于展示列表数据</p>
<p>​            2.语法：v-for=&quot;(item, index) in xxx&quot; :key=&quot;yyy&quot;</p>
<p>​            3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）</p>
<p>react、vue中的key有什么作用？（key的内部原理）</p>
<h3 id="拟dom中key的作用">拟DOM中key的作用：</h3>
<p>​                    key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,</p>
<p>​                    随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：</p>
<p>​           对比规则：</p>
<p>​                  (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：</p>
<p>​                        ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！</p>
<p>​                        ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。</p>
<p>​                  (2).旧虚拟DOM中未找到与新虚拟DOM相同的key</p>
<p>​                        创建新的真实DOM，随后渲染到到页面。</p>
<h3 id="vueset">Vue.set()</h3>
<p>给data中的响应式对象添加新属性，该对象不能是vue实例或data根数据对象</p>
<pre><code class="language-js">const vm = new Vue({
			el:'#root',
			data:{
				student:{
					name:'tom',
					age:{
						rAge:40,
						sAge:29,
					}
				}
			},
			methods: {
				addSex(){
					// Vue.set(this.student,'sex','男')
					this.$set(this.student,'sex','男')
				}
			}
		})
</code></pre>
<h2 id="数据检测原理">数据检测原理</h2>
<p>\1. vue会监视data中所有层次的数据。</p>
<p>​        \2. 如何监测对象中的数据？</p>
<p>利用数据劫持，<em>Object</em>.defineProperties()给对象每个属性添加get、set</p>
<p>​                通过setter实现监视，且要在new Vue时就传入要监测的数据。</p>
<p>​                  (1).对象中后追加的属性，Vue默认不做响应式处理</p>
<p>​                  (2).如需给后添加的属性做响应式，请使用如下API：</p>
<p>​                          Vue.set(target，propertyName/index，value) 或</p>
<p>​                          vm.$set(target，propertyName/index，value)</p>
<p>​        \3. 如何监测数组中的数据？</p>
<p>​                  通过包裹数组更新元素的方法实现，本质就是做了两件事：</p>
<p>​                    (1).调用原生对应的方法对数组进行更新。</p>
<p>​                    (2).重新解析模板，进而更新页面。</p>
<p>​        4.在Vue修改数组中的某个元素一定要用如下方法：</p>
<p>​              1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()</p>
<p>​              2.Vue.set() 或 vm.$set()</p>
<p>​			3.其他不改变原数组的方法时要重新覆盖原数组</p>
<h2 id="收集表单数据">收集表单数据</h2>
<p>若：<input type="text"/>，则v-model收集的是value值，用户输入的就是value值。</p>
<p>​          若：<input type="radio"/>，则v-model收集的是value值，且要给标签配置value值。</p>
<p>​          若：<input type="checkbox"/></p>
<p>​              1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p>
<p>​              2.配置input的value属性:</p>
<p>​                  (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）</p>
<p>​                  (2)v-model的初始值是数组，那么收集的的就是value组成的数组</p>
<p>​          备注：v-model的三个修饰符：</p>
<p>​                  lazy：失去焦点再收集数据</p>
<p>​                  number：输入字符串转为有效的数字</p>
<p>​                  trim：输入首尾空格过滤</p>
<h2 id="过滤器">过滤器</h2>
<p>定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。</p>
<p>​        语法：</p>
<p>​            1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}</p>
<p>​            2.使用过滤器：{{ xxx | 过滤器名}}  或  v-bind:属性 = &quot;xxx | 过滤器名&quot;</p>
<p>​        备注：</p>
<p>​            1.过滤器也可以接收额外参数、多个过滤器也可以串联</p>
<p>​            2.并没有改变原本的数据, 是产生新的对应的数据</p>
<pre><code class="language-js">&lt;div id=&quot;root&quot;&gt;
			&lt;h2&gt;显示格式化后的时间&lt;/h2&gt;
			&lt;!-- 计算属性实现 --&gt;
			&lt;h3&gt;现在是：{{fmtTime}}&lt;/h3&gt;
			&lt;!-- methods实现 --&gt;
			&lt;h3&gt;现在是：{{getFmtTime()}}&lt;/h3&gt;
			&lt;!-- 过滤器实现 --&gt;
			&lt;h3&gt;现在是：{{time | timeFormater}}&lt;/h3&gt;
			&lt;!-- 过滤器实现（传参） --&gt;
			&lt;h3&gt;现在是：{{time | timeFormater('YYYY_MM_DD') | mySlice}}&lt;/h3&gt;
			&lt;h3 :x=&quot;msg | mySlice&quot;&gt;尚硅谷&lt;/h3&gt;
		&lt;/div&gt;
	&lt;/body&gt;

		//全局过滤器
		Vue.filter('mySlice',function(value){
			return value.slice(0,4)
		})
		
		new Vue({
			el:'#root',
			data:{
				time:1621561377603, //时间戳
				msg:'你好，尚硅谷'
			},
			computed: {
				fmtTime(){
					return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss')
				}
			},
			methods: {
				getFmtTime(){
					return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss')
				}
			},
			//局部过滤器
			filters:{
				timeFormater(value,str='YYYY年MM月DD日 HH:mm:ss'){
					return dayjs(value).format(str)
				}
			}
		})
</code></pre>
<h2 id="vue指令">Vue指令</h2>
<h3 id="v-bind">v-bind</h3>
<p>单向绑定解析表达式, 可简写为 :xxx</p>
<h3 id="v-model">v-model</h3>
<p>双向数据绑定</p>
<h3 id="v-for">v-for</h3>
<p>遍历数组/对象/字符串</p>
<h3 id="v-on">v-on</h3>
<p>绑定事件监听, 可简写为@</p>
<h3 id="v-if">v-if</h3>
<p>条件渲染（动态控制节点是否存存在）</p>
<h3 id="v-else">v-else</h3>
<p>条件渲染（动态控制节点是否存存在）</p>
<h3 id="v-show">v-show</h3>
<p>条件渲染 (动态控制节点是否展示)</p>
<h3 id="v-text">v-text</h3>
<p>1.作用：向其所在的节点中渲染文本内容。</p>
<p>2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。</p>
<h3 id="v-html">v-html</h3>
<p>1.作用：向指定节点中渲染包含html结构的内容。</p>
<p>2.与插值语法的区别：</p>
<p>​                  (1).v-html会替换掉节点中所有的内容，{{xx}}则不会。</p>
<p>​                  (2).v-html可以识别html结构。</p>
<p>3.严重注意：v-html有安全性问题！！！！</p>
<p>​                  (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。</p>
<p>​                  (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！</p>
<h3 id="v-clock">v-clock</h3>
<p>1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。</p>
<p>2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。</p>
<pre><code class="language-js">&lt;style&gt;
    [v-cloak]{
    	display:none;
    }
&lt;/style&gt;

&lt;div id=&quot;root&quot;&gt;
    &lt;h2 v-cloak&gt;{{name}}&lt;/h2&gt;
&lt;/div&gt;
</code></pre>
<h3 id="v-once">v-once</h3>
<p>1.v-once所在节点在初次动态渲染后，就视为静态内容了。</p>
<p>2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。</p>
<pre><code class="language-js">&lt;h2 v-once&gt;初始化的n值是:{{n}}&lt;/h2&gt;
</code></pre>
<h3 id="v-pre">v-pre</h3>
<p>1.跳过其所在节点的编译过程。</p>
<p>2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。</p>
<h3 id="自定义指令">自定义指令</h3>
<p>一、定义语法：</p>
<p>​                  (1).局部指令：</p>
<p>​                        new Vue({                              new Vue({</p>
<p>​                          directives:{指令名:配置对象}  或      directives{指令名:回调函数}</p>
<p>​                        })                                    })</p>
<p>​                  (2).全局指令：</p>
<p>​                          Vue.directive(指令名,配置对象) 或  Vue.directive(指令名,回调函数)</p>
<p>​            二、配置对象中常用的3个回调：</p>
<p>​                  (1).bind：指令与元素成功绑定时调用。</p>
<p>​                  (2).inserted：指令所在元素被插入页面时调用。</p>
<p>​                  (3).update：指令所在模板结构被重新解析时调用。</p>
<p>​            三、备注：</p>
<p>​                  1.指令定义时不加v-，但使用时要加v-；</p>
<p>​                  2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。</p>
<p>​					3.this指向window</p>
<h2 id="生命周期">生命周期</h2>
<p>生命周期函数中的this指向是vm 或 组件实例对象</p>
<p>生命周期回调函数、生命周期函数、生命周期钩子</p>
<p>常用的生命周期钩子：</p>
<p>​            1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。</p>
<p>​            2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。</p>
<p>​        关于销毁Vue实例</p>
<p>​            1.销毁后借助Vue开发者工具看不到任何信息。</p>
<p>​            2.销毁后自定义事件会失效，但原生DOM事件依然有效。</p>
<p>​            3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。</p>
<h2 id="组件">组件</h2>
<figure data-type="image" tabindex="1"><a href="https://postimg.cc/yk9PsjxD"><img src="https://i.postimg.cc/L6Q0k0M3/image-20220812085646674.png" alt="image-20220812085646674.png" loading="lazy"></a></figure>
<h2 id="ref属性">ref属性</h2>
<ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：
<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2 id="props配置项"><strong>props配置项</strong></h2>
<ol>
<li>
<p>功能：让组件接收外部传过来的数据</p>
</li>
<li>
<p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li>
<p>接收数据：</p>
<ol>
<li>
<p>第一种方式（只接收）：<code>props:['name'] </code></p>
</li>
<li>
<p>第二种方式（限制类型）：<code>props:{name:String}</code></p>
</li>
<li>
<p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
<pre><code class="language-js">props:{
 name:{
 type:String, //类型
 required:true, //必要性
 default:'老王' //默认值
 }
}
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
<p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</blockquote>
</li>
</ol>
<h2 id="mixin混入">mixin(混入)</h2>
<ol>
<li>
<p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li>
<p>使用方式：</p>
<p>第一步定义混合：</p>
<pre><code>{
    data(){....},
    methods:{....}
    ....
}
</code></pre>
<p>第二步使用混入：</p>
<p>全局混入：<code>Vue.mixin(xxx)</code><br>
局部混入：<code>mixins:['xxx']  </code></p>
</li>
</ol>
<h2 id="插件">插件</h2>
<ol>
<li>
<p>功能：用于增强Vue</p>
</li>
<li>
<p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li>
<p>定义插件：</p>
<pre><code class="language-js">对象.install = function (Vue, options) {
    // 1. 添加全局过滤器
    Vue.filter(....)

    // 2. 添加全局指令
    Vue.directive(....)

    // 3. 配置全局混入(合)
    Vue.mixin(....)

    // 4. 添加实例方法
    Vue.prototype.$myMethod = function () {...}
    Vue.prototype.$myProperty = xxxx
}
</code></pre>
</li>
<li>
<p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2 id="scoped样式"><strong>scoped样式</strong></h2>
<p>\1. 作用：让样式在局部生效，防止冲突。</p>
<p>\2. 写法：<code>&lt;style scoped&gt;</code></p>
<h2 id="自定义事件">自定义事件</h2>
<p>\1. 一种组件间通信的方式，适用于：<strong>子组件 ===&gt; 父组件</strong></p>
<p>\2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（&lt;span <em>style</em>=&quot;color:red&quot;&gt;事件的回调在A中</span>）。</p>
<p>\3. 绑定自定义事件：</p>
<pre><code>1. 第一种方式，在父组件中：```&lt;Demo @atguigu=&quot;test&quot;/&gt;```  或 ```&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;```

    2. 第二种方式，在父组件中：

    ```js
    &lt;Demo ref=&quot;demo&quot;/&gt;
    ......
    mounted(){
       this.$refs.xxx.$on('atguigu',this.test)
    }
    ```

    3. 若想让自定义事件只能触发一次，可以使用```once```修饰符，或```$once```方法。
</code></pre>
<ol start="4">
<li>
<p>触发自定义事件：<code>this.$emit('atguigu',数据)</code></p>
</li>
<li>
<p>解绑自定义事件<code>this.$off('atguigu')</code></p>
</li>
<li>
<p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。</p>
</li>
<li>
<p>注意：通过<code>this.$refs.xxx.$on('atguigu',回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线globaleventbus">全局事件总线（GlobalEventBus）</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>安装全局事件总线：</p>
<pre><code class="language-js">new Vue({
   ......
   beforeCreate() {
      Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
   },
    ......
}) 
</code></pre>
</li>
<li>
<p>使用事件总线：</p>
<ol>
<li>
<p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.$bus.$on('xxxx',this.demo)
}
</code></pre>
</li>
<li>
<p>提供数据：<code>this.$bus.$emit('xxxx',数据)</code></p>
</li>
</ol>
</li>
<li>
<p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布pubsub">消息订阅与发布（pubsub）</h2>
<ol>
<li>
<p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li>
<p>使用步骤：</p>
<ol>
<li>
<p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li>
<p>引入: <code>import pubsub from 'pubsub-js'</code></p>
</li>
<li>
<p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<pre><code class="language-js">methods(){
  demo(data){......}
}
......
mounted() {
  this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息
}
</code></pre>
</li>
<li>
<p>提供数据：<code>pubsub.publish('xxx',数据)</code></p>
</li>
<li>
<p>最好在beforeDestroy钩子中，用<code>PubSub.unsubscribe(this.pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="nexttick">nextTick</h2>
<ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<h2 id="vue封装的过度与动画">Vue封装的过度与动画</h2>
<ol>
<li>
<p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li>
<p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105"/></p>
</li>
<li>
<p>写法：</p>
<ol>
<li>
<p>准备好样式：</p>
<ul>
<li>元素进入的样式：
<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：
<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li>
<p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<pre><code class="language-vue">&lt;transition name=&quot;hello&quot;&gt;
   &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;
&lt;/transition&gt;
</code></pre>
</li>
<li>
<p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="vue脚手架配置代理">vue脚手架配置代理</h2>
<h3 id="方法一">方法一</h3>
<p>在vue.config.js中添加如下配置：</p>
<pre><code class="language-js">devServer:{
  proxy:&quot;http://localhost:5000&quot;
}
</code></pre>
<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二">方法二</h3>
<p>编写vue.config.js配置具体代理规则：</p>
<pre><code class="language-js">module.exports = {
   devServer: {
      proxy: {
      '/api1': {// 匹配所有以 '/api1'开头的请求路径
        target: 'http://localhost:5000',// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {'^/api1': ''}
      },
      '/api2': {// 匹配所有以 '/api2'开头的请求路径
        target: 'http://localhost:5001',// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {'^/api2': ''}
      }
    }
  }
}
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
</code></pre>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="插槽">插槽</h2>
<ol>
<li>
<p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===&gt; 子组件</strong> 。</p>
</li>
<li>
<p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li>
<p>使用方式：</p>
<ol>
<li>
<p>默认插槽：</p>
<pre><code class="language-vue">父组件中：
        &lt;Category&gt;
           &lt;div&gt;html结构1&lt;/div&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li>
<p>具名插槽：</p>
<pre><code class="language-vue">父组件中：
        &lt;Category&gt;
            &lt;template slot=&quot;center&quot;&gt;
              &lt;div&gt;html结构1&lt;/div&gt;
            &lt;/template&gt;

            &lt;template v-slot:footer&gt;
               &lt;div&gt;html结构2&lt;/div&gt;
            &lt;/template&gt;
        &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
               &lt;!-- 定义插槽 --&gt;
               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;
               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
</code></pre>
</li>
<li>
<p>作用域插槽：</p>
<ol>
<li>
<p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-vue">父组件中：
      &lt;Category&gt;
         &lt;template scope=&quot;scopeData&quot;&gt;
            &lt;!-- 生成的是ul列表 --&gt;
            &lt;ul&gt;
               &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/li&gt;
            &lt;/ul&gt;
         &lt;/template&gt;
      &lt;/Category&gt;

      &lt;Category&gt;
         &lt;template slot-scope=&quot;scopeData&quot;&gt;
            &lt;!-- 生成的是h4标题 --&gt;
            &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;{{g}}&lt;/h4&gt;
         &lt;/template&gt;
      &lt;/Category&gt;
子组件中：
        &lt;template&gt;
            &lt;div&gt;
                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/template&gt;
      
        &lt;script&gt;
            export default {
                name:'Category',
                props:['title'],
                //数据在子组件自身
                data() {
                    return {
                        games:['红色警戒','穿越火线','劲舞团','超级玛丽']
                    }
                },
            }
        &lt;/script&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<pre><code>
</code></pre>
</li>
</ol>
<h2 id="vuex">Vuex</h2>
<h3 id="1概念">1.概念</h3>
<p>​     在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2何时使用">2.何时使用？</h3>
<p>​     多个组件需要共享数据时</p>
<h3 id="3搭建vuex环境">3.搭建vuex环境</h3>
<ol>
<li>
<p>创建文件：<code>src/store/index.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from 'vue'
//引入Vuex
import Vuex from 'vuex'
//应用Vuex插件
Vue.use(Vuex)

//准备actions对象——响应组件中用户的动作
const actions = {}
//准备mutations对象——修改state中的数据
const mutations = {}
//准备state对象——保存具体的数据
const state = {}

//创建并暴露store
export default new Vuex.Store({
   actions,
   mutations,
   state
})
</code></pre>
</li>
<li>
<p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<pre><code class="language-js">......
//引入store
import store from './store'
......

//创建vm
new Vue({
   el:'#app',
   render: h =&gt; h(App),
   store
})
</code></pre>
</li>
</ol>
<h3 id="4基本使用">4.基本使用</h3>
<ol>
<li>
<p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<pre><code class="language-js">//引入Vue核心库
import Vue from 'vue'
//引入Vuex
import Vuex from 'vuex'
//引用Vuex
Vue.use(Vuex)

const actions = {
    //响应组件中加的动作
   jia(context,value){
      // console.log('actions中的jia被调用了',miniStore,value)
      context.commit('JIA',value)
   },
}

const mutations = {
    //执行加
   JIA(state,value){
      // console.log('mutations中的JIA被调用了',state,value)
      state.sum += value
   }
}

//初始化数据
const state = {
   sum:0
}

//创建并暴露store
export default new Vuex.Store({
   actions,
   mutations,
   state,
})
</code></pre>
</li>
<li>
<p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li>
<p>组件中修改vuex中的数据：<code>$store.dispatch('action中的方法名',数据)</code> 或 <code>$store.commit('mutations中的方法名',数据)</code></p>
<blockquote>
<p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5getters的使用">5.getters的使用</h3>
<ol>
<li>
<p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li>
<p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<pre><code class="language-js">......

const getters = {
   bigSum(state){
      return state.sum * 10
   }
}

//创建并暴露store
export default new Vuex.Store({
   ......
   getters
})
</code></pre>
</li>
<li>
<p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6四个map方法的使用">6.四个map方法的使用</h3>
<ol>
<li>
<p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapState生成计算属性：sum、school、subject（对象写法）
     ...mapState({sum:'sum',school:'school',subject:'subject'}),
         
    //借助mapState生成计算属性：sum、school、subject（数组写法）
    ...mapState(['sum','school','subject']),
},
</code></pre>
</li>
<li>
<p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<pre><code class="language-js">computed: {
    //借助mapGetters生成计算属性：bigSum（对象写法）
    ...mapGetters({bigSum:'bigSum'}),

    //借助mapGetters生成计算属性：bigSum（数组写法）
    ...mapGetters(['bigSum'])
},
</code></pre>
</li>
<li>
<p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：incrementOdd、incrementWait（对象形式）
    ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})

    //靠mapActions生成：incrementOdd、incrementWait（数组形式）
    ...mapActions(['jiaOdd','jiaWait'])
}
</code></pre>
</li>
<li>
<p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<pre><code class="language-js">methods:{
    //靠mapActions生成：increment、decrement（对象形式）
    ...mapMutations({increment:'JIA',decrement:'JIAN'}),
    
    //靠mapMutations生成：JIA、JIAN（对象形式）
    ...mapMutations(['JIA','JIAN']),
}
</code></pre>
</li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7模块化命名空间">7.模块化+命名空间</h3>
<ol>
<li>
<p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li>
<p>修改<code>store.js</code></p>
<pre><code class="language-javascript">const countAbout = {
  namespaced:true,//开启命名空间
  state:{x:1},
  mutations: { ... },
  actions: { ... },
  getters: {
    bigSum(state){
       return state.sum * 10
    }
  }
}

const personAbout = {
  namespaced:true,//开启命名空间
  state:{ ... },
  mutations: { ... },
  actions: { ... }
}

const store = new Vuex.Store({
  modules: {
    countAbout,
    personAbout
  }
})
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中读取state数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState('countAbout',['sum','school','subject']),
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中读取getters数据：</p>
<pre><code class="language-js">//方式一：自己直接读取
this.$store.getters['personAbout/firstPersonName']
//方式二：借助mapGetters读取：
...mapGetters('countAbout',['bigSum'])
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中调用dispatch</p>
<pre><code class="language-js">//方式一：自己直接dispatch
this.$store.dispatch('personAbout/addPersonWang',person)
//方式二：借助mapActions：
...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
</code></pre>
</li>
<li>
<p>开启命名空间后，组件中调用commit</p>
<pre><code class="language-js">//方式一：自己直接commit
this.$store.commit('personAbout/ADD_PERSON',person)
//方式二：借助mapMutations：
...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),
</code></pre>
</li>
</ol>
<h2 id="路由">路由</h2>
<ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="1基本使用">1.基本使用</h3>
<ol>
<li>
<p>安装vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li>
<p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li>
<p>编写router配置项:</p>
<pre><code class="language-js">//引入VueRouter
import VueRouter from 'vue-router'
//引入Luyou 组件
import About from '../components/About'
import Home from '../components/Home'

//创建router实例对象，去管理一组一组的路由规则
const router = new VueRouter({
   routes:[
      {
         path:'/about',
         component:About
      },
      {
         path:'/home',
         component:Home
      }
   ]
})

//暴露router
export default router
</code></pre>
</li>
<li>
<p>实现切换（active-class可配置高亮样式）</p>
<pre><code class="language-vue">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;
</code></pre>
</li>
<li>
<p>指定展示位置</p>
<pre><code class="language-vue">&lt;router-view&gt;&lt;/router-view&gt;
</code></pre>
</li>
</ol>
<h3 id="2几个注意点">2.几个注意点</h3>
<ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3多级路由多级路由">3.多级路由（多级路由）</h3>
<ol>
<li>
<p>配置路由规则，使用children配置项：</p>
<pre><code class="language-js">routes:[
   {
      path:'/about',
      component:About,
   },
   {
      path:'/home',
      component:Home,
      children:[ //通过children配置子级路由
         {
            path:'news', //此处一定不要写：/news
            component:News
         },
         {
            path:'message',//此处一定不要写：/message
            component:Message
         }
      ]
   }
]
</code></pre>
</li>
<li>
<p>跳转（要写完整路径）：</p>
<pre><code class="language-vue">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;
</code></pre>
</li>
</ol>
<h3 id="4路由的query参数">4.路由的query参数</h3>
<ol>
<li>
<p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;
            
&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;
&lt;router-link 
   :to=&quot;{
      path:'/home/message/detail',
      query:{
         id:666,
            title:'你好'
      }
   }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
<li>
<p>接收参数：</p>
<pre><code class="language-js">$route.query.id
$route.query.title
</code></pre>
</li>
</ol>
<h3 id="5命名路由">5.命名路由</h3>
<ol>
<li>
<p>作用：可以简化路由的跳转。</p>
</li>
<li>
<p>如何使用</p>
<ol>
<li>
<p>给路由命名：</p>
<pre><code class="language-js">{
   path:'/demo',
   component:Demo,
   children:[
      {
         path:'test',
         component:Test,
         children:[
            {
                      name:'hello' //给路由命名
               path:'welcome',
               component:Hello,
            }
         ]
      }
   ]
}
</code></pre>
</li>
<li>
<p>简化跳转：</p>
<pre><code class="language-vue">&lt;!--简化前，需要写完整的路径 --&gt;
&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化后，直接通过名字跳转 --&gt;
&lt;router-link :to=&quot;{name:'hello'}&quot;&gt;跳转&lt;/router-link&gt;

&lt;!--简化写法配合传递参数 --&gt;
&lt;router-link 
   :to=&quot;{
      name:'hello',
      query:{
         id:666,
            title:'你好'
      }
   }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="6路由的params参数">6.路由的params参数</h3>
<ol>
<li>
<p>配置路由，声明接收params参数</p>
<pre><code class="language-js">{
   path:'/home',
   component:Home,
   children:[
      {
         path:'news',
         component:News
      },
      {
         component:Message,
         children:[
            {
               name:'xiangqing',
               path:'detail/:id/:title', //使用占位符声明接收params参数
               component:Detail
            }
         ]
      }
   ]
}
</code></pre>
</li>
<li>
<p>传递参数</p>
<pre><code class="language-vue">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;
&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;
            
&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;
&lt;router-link 
   :to=&quot;{
      name:'xiangqing',
      params:{
         id:666,
            title:'你好'
      }
   }&quot;
&gt;跳转&lt;/router-link&gt;
</code></pre>
<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li>
<p>接收参数：</p>
<pre><code class="language-js">$route.params.id
$route.params.title
</code></pre>
</li>
</ol>
<h3 id="7路由的props配置">7.路由的props配置</h3>
<p>作用：让路由组件更方便的收到参数</p>
<pre><code class="language-js">{
   name:'xiangqing',
   path:'detail/:id',
   component:Detail,

   //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
   // props:{a:900}

   //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
   // props:true
   
   //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
   props(route){
      return {
         id:route.query.id,
         title:route.query.title
      }
   }
}
</code></pre>
<h3 id="8router-link的replace属性">8.<code>&lt;router-link&gt;</code>的replace属性</h3>
<ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9编程式路由导航">9.编程式路由导航</h3>
<ol>
<li>
<p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-js">//$router的两个API
this.$router.push({
   name:'xiangqing',
      params:{
         id:xxx,
         title:xxx
      }
})

this.$router.replace({
   name:'xiangqing',
      params:{
         id:xxx,
         title:xxx
      }
})
this.$router.forward() //前进
this.$router.back() //后退
this.$router.go() //可前进也可后退
</code></pre>
</li>
</ol>
<h3 id="10缓存路由组件">10.缓存路由组件</h3>
<ol>
<li>
<p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li>
<p>具体编码：</p>
<pre><code class="language-vue">&lt;keep-alive include=&quot;News&quot;&gt; 
    &lt;router-view&gt;&lt;/router-view&gt;
&lt;/keep-alive&gt;
</code></pre>
</li>
</ol>
<h3 id="11两个新的生命周期钩子">11.两个新的生命周期钩子</h3>
<ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：
<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12路由守卫">12.路由守卫</h3>
<ol>
<li>
<p>作用：对路由进行权限控制</p>
</li>
<li>
<p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li>
<p>全局守卫:</p>
<pre><code class="language-js">//全局前置守卫：初始化时执行、每次路由切换前执行
router.beforeEach((to,from,next)=&gt;{
   console.log('beforeEach',to,from)
   if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
      if(localStorage.getItem('school') === 'atguigu'){ //权限控制的具体规则
         next() //放行
      }else{
         alert('暂无权限查看')
         // next({name:'guanyu'})
      }
   }else{
      next() //放行
   }
})

//全局后置守卫：初始化时执行、每次路由切换后执行
router.afterEach((to,from)=&gt;{
   console.log('afterEach',to,from)
   if(to.meta.title){ 
      document.title = to.meta.title //修改网页的title
   }else{
      document.title = 'vue_test'
   }
})
</code></pre>
</li>
<li>
<p>独享守卫:</p>
<pre><code class="language-js">beforeEnter(to,from,next){
   console.log('beforeEnter',to,from)
   if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
      if(localStorage.getItem('school') === 'atguigu'){
         next()
      }else{
         alert('暂无权限查看')
         // next({name:'guanyu'})
      }
   }else{
      next()
   }
}
</code></pre>
</li>
<li>
<p>组件内守卫：</p>
<pre><code class="language-js">//进入守卫：通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) {
},
//离开守卫：通过路由规则，离开该组件时被调用
beforeRouteLeave (to, from, next) {
}
</code></pre>
</li>
</ol>
<h3 id="13路由器的两种工作模式">13.路由器的两种工作模式</h3>
<ol>
<li>
<p>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</p>
</li>
<li>
<p>hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。</p>
</li>
<li>
<p>hash模式：</p>
<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>
<p>history模式：</p>
<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</li>
</ol>
</li>
</ol>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://kingshuxin.github.io/post/vue3/">
                  <h3 class="post-title">
                    Vue3
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
